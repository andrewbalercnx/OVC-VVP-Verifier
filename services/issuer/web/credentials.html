<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VVP Issuer - Credentials</title>
    <link rel="stylesheet" href="/static/styles.css">
    <style>
      /* Page-specific styles for dynamic form */
      button.danger { background: #e74c3c; }
      button.danger:hover { background: #c0392b; }
      .hint { font-size: 0.875rem; color: #666; margin-top: 0.25rem; }

      /* Dynamic form fields */
      .dynamic-form .form-group { margin-bottom: 1rem; }
      .dynamic-form label { display: block; margin-bottom: 0.25rem; font-weight: 500; font-size: 0.9rem; }
      .dynamic-form .field-hint { font-size: 0.8rem; color: #888; margin-top: 0.15rem; }
      .dynamic-form input[type="text"],
      .dynamic-form input[type="number"],
      .dynamic-form input[type="datetime-local"],
      .dynamic-form select {
        width: 100%;
        padding: 0.6rem;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.95rem;
        box-sizing: border-box;
      }
      .dynamic-form input:focus, .dynamic-form select:focus {
        outline: none;
        border-color: var(--vvp-primary);
        box-shadow: 0 0 0 2px rgba(52,152,219,0.2);
      }
      .dynamic-form .checkbox-field { display: flex; align-items: center; gap: 0.5rem; }
      .dynamic-form .checkbox-field input { width: auto; }
      .dynamic-form .checkbox-field label { margin: 0; font-weight: normal; }

      /* Array fields */
      .array-field {
        border: 1px solid #e9ecef;
        border-radius: 4px;
        padding: 1rem;
        background: #fafafa;
        margin-top: 0.25rem;
      }
      .array-item { display: flex; gap: 0.5rem; margin-bottom: 0.5rem; align-items: center; }
      .array-item input { flex: 1; }
      .array-item button { padding: 0.4rem 0.6rem; font-size: 0.8rem; background: #e74c3c; }
      .array-item button:hover { background: #c0392b; }
      .add-array-item { background: #27ae60; padding: 0.4rem 0.8rem; font-size: 0.85rem; margin-top: 0.5rem; }
      .add-array-item:hover { background: #219a52; }

      /* Nested objects */
      .nested-object {
        border: 1px solid var(--vvp-border);
        border-radius: 4px;
        padding: 1rem;
        margin-top: 0.5rem;
        background: #fcfcfc;
      }
      .nested-object-title {
        font-weight: 500;
        margin-bottom: 0.75rem;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid #eee;
        color: var(--vvp-text);
      }
      .required-indicator { color: #e74c3c; margin-left: 2px; }
    </style>
  </head>
  <body>
    <header class="site-header">
      <div class="header-brand">
        <img src="/static/ovc-logo.png" alt="OVC" class="ovc-logo">
        <a href="/ui/" class="logo">
          <span class="service-label">VVP</span>
          Issuer
        </a>
      </div>
      <nav class="nav-links">
        <a href="/ui/identity">Identities</a>
        <a href="/ui/registry">Registries</a>
        <a href="/ui/schemas">Schemas</a>
        <a href="/ui/credentials" class="active">Credentials</a>
        <a href="/ui/dossier">Dossiers</a>
        <a href="/ui/admin">Admin</a>
        <a href="https://vvp-verifier.rcnx.io" class="verifier-link" target="_blank">Verifier ↗</a>
      </nav>
    </header>

    <h1>Credential Management</h1>
    <p class="subtitle">Issue and manage ACDC credentials</p>

    <!-- Issue Credential Form -->
    <div class="card">
      <h2>Issue Credential</h2>
      <form id="issueForm">
        <div class="form-group">
          <label for="registry">Registry</label>
          <select id="registry" required>
            <option value="">Loading registries...</option>
          </select>
        </div>

        <div class="form-group">
          <label for="schema">Schema</label>
          <select id="schema" required>
            <option value="">Loading schemas...</option>
          </select>
        </div>

        <div class="form-group">
          <label>Attributes</label>
          <div class="tabs" id="inputModeTabs">
            <button type="button" class="tab active" data-mode="form">Form Mode</button>
            <button type="button" class="tab" data-mode="json">Advanced (JSON)</button>
          </div>
          <div id="formModePanel" class="tab-panel active">
            <div id="dynamicFormContainer" class="dynamic-form">
              <p class="hint">Select a schema to see the form fields</p>
            </div>
          </div>
          <div id="jsonModePanel" class="tab-panel">
            <textarea id="attributes" placeholder='{"numbers": {"tn": ["+12025551234"]}, "channel": "voice", "doNotOriginate": false}'></textarea>
            <p class="hint">Enter the credential attributes as valid JSON. The structure depends on the selected schema.</p>
          </div>
        </div>

        <div class="form-group">
          <label for="recipient">Recipient AID (optional)</label>
          <input type="text" id="recipient" placeholder="Leave empty for untargeted credential"/>
        </div>

        <div class="checkbox-row">
          <input type="checkbox" id="private"/>
          <label for="private">Add privacy-preserving nonces</label>
        </div>

        <div class="checkbox-row">
          <input type="checkbox" id="publishWitnesses" checked/>
          <label for="publishWitnesses">Publish to witnesses</label>
        </div>

        <button type="submit" id="issueBtn">Issue Credential</button>
      </form>

      <div id="issueResult"></div>
    </div>

    <!-- Credentials List -->
    <div class="card">
      <h2>Issued Credentials</h2>
      <div id="credentialsList">
        <p class="loading">Loading credentials...</p>
      </div>
    </div>

    <script>
      const registrySelect = document.getElementById('registry');
      const schemaSelect = document.getElementById('schema');
      const attributesInput = document.getElementById('attributes');
      const recipientInput = document.getElementById('recipient');
      const privateCheck = document.getElementById('private');
      const publishCheck = document.getElementById('publishWitnesses');
      const issueForm = document.getElementById('issueForm');
      const issueBtn = document.getElementById('issueBtn');
      const issueResult = document.getElementById('issueResult');
      const credentialsList = document.getElementById('credentialsList');
      const dynamicFormContainer = document.getElementById('dynamicFormContainer');
      const formModePanel = document.getElementById('formModePanel');
      const jsonModePanel = document.getElementById('jsonModePanel');
      const modeTabs = document.querySelectorAll('#inputModeTabs .tab');

      // Track current input mode
      let currentMode = 'form';
      let currentSchemaDoc = null;

      // System fields to skip (auto-populated by backend)
      const SYSTEM_FIELDS = ['d', 'u', 'i', 'dt'];

      // Tab switching
      modeTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const mode = tab.dataset.mode;
          if (mode === currentMode) return;

          // Sync data before switching
          if (currentMode === 'form' && mode === 'json') {
            // Form -> JSON: collect form data to textarea
            const formData = FormDataCollector.collect(dynamicFormContainer);
            if (Object.keys(formData).length > 0) {
              attributesInput.value = JSON.stringify(formData, null, 2);
            }
          }

          // Update tab styling
          modeTabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');

          // Show/hide panels
          formModePanel.classList.toggle('active', mode === 'form');
          jsonModePanel.classList.toggle('active', mode === 'json');
          currentMode = mode;
        });
      });

      // Schema Form Generator
      class SchemaFormGenerator {
        static async generateFromSchema(said, container) {
          container.innerHTML = '<p class="hint">Loading schema...</p>';

          try {
            const res = await fetch(`/schema/${said}`);
            if (!res.ok) throw new Error('Failed to load schema');
            const schema = await res.json();

            currentSchemaDoc = schema.schema_document;
            if (!currentSchemaDoc) {
              container.innerHTML = '<p class="hint">Schema has no document - use JSON mode</p>';
              return;
            }

            // Extract attributes schema from properties.a.oneOf[1] (the object variant)
            const attrSchema = this.extractAttributesSchema(currentSchemaDoc);
            if (!attrSchema || !attrSchema.properties) {
              container.innerHTML = '<p class="hint">Could not extract attributes schema - use JSON mode</p>';
              return;
            }

            // Generate form fields
            container.innerHTML = '';
            this.renderFields(attrSchema, container, '');

          } catch (e) {
            console.error('Schema generation error:', e);
            container.innerHTML = `<p class="error">Error loading schema: ${e.message}</p>`;
          }
        }

        static extractAttributesSchema(schemaDoc) {
          // Try properties.a.oneOf[1] first (standard ACDC structure)
          if (schemaDoc.properties?.a?.oneOf) {
            const objVariant = schemaDoc.properties.a.oneOf.find(v => v.type === 'object');
            if (objVariant) return objVariant;
          }
          // Fallback: properties.a directly if it's an object schema
          if (schemaDoc.properties?.a?.type === 'object') {
            return schemaDoc.properties.a;
          }
          // Last resort: the schema itself
          return schemaDoc;
        }

        static renderFields(schema, container, pathPrefix) {
          const required = schema.required || [];

          for (const [key, prop] of Object.entries(schema.properties || {})) {
            // Skip system fields
            if (SYSTEM_FIELDS.includes(key)) continue;

            const path = pathPrefix ? `${pathPrefix}.${key}` : key;
            const isRequired = required.includes(key);

            if (prop.type === 'object' && prop.properties) {
              // Nested object
              this.renderNestedObject(key, prop, container, path, isRequired);
            } else if (prop.type === 'array') {
              // Array field
              this.renderArrayField(key, prop, container, path, isRequired);
            } else {
              // Simple field
              this.renderSimpleField(key, prop, container, path, isRequired);
            }
          }
        }

        static renderSimpleField(key, prop, container, path, isRequired) {
          const group = document.createElement('div');
          group.className = 'form-group';

          const label = document.createElement('label');
          label.textContent = prop.title || this.formatLabel(key);
          if (isRequired) {
            const req = document.createElement('span');
            req.className = 'required-indicator';
            req.textContent = '*';
            label.appendChild(req);
          }

          let input;

          // Determine input type based on schema
          if (prop.pattern && (prop.pattern.includes('|'))) {
            // Pattern with alternatives - use select
            input = document.createElement('select');
            const options = prop.pattern.split('|').map(o => o.replace(/[^a-zA-Z0-9]/g, ''));
            const emptyOpt = document.createElement('option');
            emptyOpt.value = '';
            emptyOpt.textContent = `Select ${this.formatLabel(key)}...`;
            input.appendChild(emptyOpt);
            for (const opt of options) {
              const option = document.createElement('option');
              option.value = opt;
              option.textContent = opt;
              input.appendChild(option);
            }
          } else if (prop.format === 'date-time') {
            input = document.createElement('input');
            input.type = 'datetime-local';
          } else if (prop.type === 'boolean') {
            // Checkbox
            group.className = 'form-group checkbox-field';
            input = document.createElement('input');
            input.type = 'checkbox';
            input.id = `field_${path.replace(/\./g, '_')}`;
            label.setAttribute('for', input.id);
          } else if (prop.type === 'integer' || prop.type === 'number') {
            input = document.createElement('input');
            input.type = 'number';
            if (prop.minimum !== undefined) input.min = prop.minimum;
            if (prop.maximum !== undefined) input.max = prop.maximum;
          } else {
            input = document.createElement('input');
            input.type = 'text';
            if (prop.pattern) input.pattern = prop.pattern;
          }

          input.dataset.path = path;
          input.dataset.type = prop.type || 'string';
          if (isRequired && prop.type !== 'boolean') input.required = true;
          if (prop.default !== undefined && prop.type !== 'boolean') input.value = prop.default;
          if (prop.type === 'boolean' && prop.default === true) input.checked = true;

          if (prop.type === 'boolean') {
            group.appendChild(input);
            group.appendChild(label);
          } else {
            group.appendChild(label);
            group.appendChild(input);
          }

          // Add description hint
          if (prop.description) {
            const hint = document.createElement('p');
            hint.className = 'field-hint';
            hint.textContent = prop.description;
            group.appendChild(hint);
          }

          container.appendChild(group);
        }

        static renderArrayField(key, prop, container, path, isRequired) {
          const group = document.createElement('div');
          group.className = 'form-group';

          const label = document.createElement('label');
          label.textContent = prop.title || this.formatLabel(key);
          if (isRequired) {
            const req = document.createElement('span');
            req.className = 'required-indicator';
            req.textContent = '*';
            label.appendChild(req);
          }
          group.appendChild(label);

          const arrayContainer = document.createElement('div');
          arrayContainer.className = 'array-field';
          arrayContainer.dataset.path = path;
          arrayContainer.dataset.type = 'array';

          const itemsContainer = document.createElement('div');
          itemsContainer.className = 'array-items';

          // Add initial item
          this.addArrayItem(itemsContainer, prop.items || {}, path);

          arrayContainer.appendChild(itemsContainer);

          // Add button
          const addBtn = document.createElement('button');
          addBtn.type = 'button';
          addBtn.className = 'add-array-item';
          addBtn.textContent = '+ Add';
          addBtn.onclick = () => this.addArrayItem(itemsContainer, prop.items || {}, path);
          arrayContainer.appendChild(addBtn);

          group.appendChild(arrayContainer);
          container.appendChild(group);
        }

        static addArrayItem(container, itemSchema, basePath) {
          const idx = container.children.length;
          const itemDiv = document.createElement('div');
          itemDiv.className = 'array-item';

          const input = document.createElement('input');
          input.type = 'text';
          input.dataset.path = `${basePath}[${idx}]`;
          input.dataset.type = itemSchema.type || 'string';
          if (itemSchema.pattern) input.pattern = itemSchema.pattern;
          if (itemSchema.format === 'phone') input.placeholder = '+12025551234';

          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.textContent = '×';
          removeBtn.onclick = () => {
            itemDiv.remove();
            this.reindexArrayItems(container, basePath);
          };

          itemDiv.appendChild(input);
          itemDiv.appendChild(removeBtn);
          container.appendChild(itemDiv);
        }

        static reindexArrayItems(container, basePath) {
          const items = container.querySelectorAll('.array-item input');
          items.forEach((input, idx) => {
            input.dataset.path = `${basePath}[${idx}]`;
          });
        }

        static renderNestedObject(key, prop, container, path, isRequired) {
          const group = document.createElement('div');
          group.className = 'form-group';

          const nested = document.createElement('div');
          nested.className = 'nested-object';

          const title = document.createElement('div');
          title.className = 'nested-object-title';
          title.textContent = prop.title || this.formatLabel(key);
          if (isRequired) {
            const req = document.createElement('span');
            req.className = 'required-indicator';
            req.textContent = ' *';
            title.appendChild(req);
          }
          nested.appendChild(title);

          // Render nested fields
          this.renderFields(prop, nested, path);

          group.appendChild(nested);
          container.appendChild(group);
        }

        static formatLabel(key) {
          // Convert camelCase to Title Case
          return key
            .replace(/([A-Z])/g, ' $1')
            .replace(/^./, str => str.toUpperCase())
            .trim();
        }
      }

      // Form Data Collector
      class FormDataCollector {
        static collect(container) {
          const data = {};
          const inputs = container.querySelectorAll('[data-path]');

          inputs.forEach(input => {
            const path = input.dataset.path;
            const type = input.dataset.type;

            let value;
            if (input.type === 'checkbox') {
              value = input.checked;
            } else if (type === 'integer') {
              value = input.value ? parseInt(input.value, 10) : undefined;
            } else if (type === 'number') {
              value = input.value ? parseFloat(input.value) : undefined;
            } else if (type === 'boolean') {
              value = input.checked;
            } else {
              value = input.value || undefined;
            }

            // Skip empty values (except booleans)
            if (value === undefined || value === '') return;

            this.setNestedValue(data, path, value);
          });

          return data;
        }

        static setNestedValue(obj, path, value) {
          // Parse path like "numbers.tn[0]" or "channel"
          const parts = path.match(/[^.\[\]]+|\[\d+\]/g) || [];

          let current = obj;
          for (let i = 0; i < parts.length - 1; i++) {
            let part = parts[i];
            const nextPart = parts[i + 1];

            // Handle array index
            if (part.startsWith('[')) {
              part = parseInt(part.slice(1, -1), 10);
            }

            // Determine if next level is array or object
            const nextIsArray = nextPart && nextPart.startsWith('[');

            if (current[part] === undefined) {
              current[part] = nextIsArray ? [] : {};
            }
            current = current[part];
          }

          // Set the final value
          let finalPart = parts[parts.length - 1];
          if (finalPart.startsWith('[')) {
            finalPart = parseInt(finalPart.slice(1, -1), 10);
          }
          current[finalPart] = value;
        }
      }

      // Schema selection triggers form generation
      schemaSelect.addEventListener('change', async () => {
        const said = schemaSelect.value;
        if (!said) {
          dynamicFormContainer.innerHTML = '<p class="hint">Select a schema to see the form fields</p>';
          currentSchemaDoc = null;
          return;
        }
        await SchemaFormGenerator.generateFromSchema(said, dynamicFormContainer);
      });

      // Load registries
      async function loadRegistries() {
        try {
          const res = await fetch('/registry');
          if (!res.ok) {
            registrySelect.innerHTML = '<option value="">Unable to load registries</option>';
            return;
          }
          const data = await res.json();

          registrySelect.innerHTML = '<option value="">Select a registry...</option>';
          if (data.count === 0) {
            registrySelect.innerHTML = '<option value="">No registries - create one first</option>';
            return;
          }
          for (const reg of data.registries) {
            const option = document.createElement('option');
            option.value = reg.name;
            option.textContent = `${reg.name} (${reg.registry_key.substring(0, 12)}...)`;
            registrySelect.appendChild(option);
          }
        } catch (e) {
          registrySelect.innerHTML = '<option value="">Unable to load registries</option>';
          console.error(e);
        }
      }

      // Load schemas
      async function loadSchemas() {
        try {
          const res = await fetch('/schema');
          if (!res.ok) {
            schemaSelect.innerHTML = '<option value="">Unable to load schemas</option>';
            return;
          }
          const data = await res.json();

          schemaSelect.innerHTML = '<option value="">Select a schema...</option>';
          if (data.count === 0) {
            schemaSelect.innerHTML = '<option value="">No schemas available</option>';
            return;
          }
          for (const schema of data.schemas) {
            const option = document.createElement('option');
            option.value = schema.said;
            option.textContent = schema.title;
            schemaSelect.appendChild(option);
          }
        } catch (e) {
          schemaSelect.innerHTML = '<option value="">Unable to load schemas</option>';
          console.error(e);
        }
      }

      // Load credentials
      async function loadCredentials() {
        try {
          const res = await fetch('/credential');
          if (!res.ok) {
            credentialsList.innerHTML = '<p class="hint">Unable to load credentials.</p>';
            return;
          }
          const data = await res.json();

          if (!data.credentials || data.credentials.length === 0) {
            credentialsList.innerHTML = '<p class="hint">No credentials issued yet. Use the form above to issue your first credential.</p>';
            return;
          }

          let html = `
            <table>
              <thead>
                <tr>
                  <th>SAID</th>
                  <th>Schema</th>
                  <th>Status</th>
                  <th>Issued</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody>
          `;

          for (const cred of data.credentials) {
            const statusClass = cred.status === 'issued' ? 'status-issued' : 'status-revoked';
            const issuedDate = cred.issuance_dt ? new Date(cred.issuance_dt).toLocaleDateString() : 'N/A';

            html += `
              <tr>
                <td class="said-cell" title="${cred.said}">${cred.said.substring(0, 16)}...</td>
                <td class="said-cell" title="${cred.schema_said}">${cred.schema_said.substring(0, 12)}...</td>
                <td><span class="status-badge ${statusClass}">${cred.status}</span></td>
                <td>${issuedDate}</td>
                <td>
                  ${cred.status === 'issued' ? `<button class="small danger" onclick="revokeCredential('${cred.said}')">Revoke</button>` : ''}
                </td>
              </tr>
            `;
          }

          html += '</tbody></table>';
          credentialsList.innerHTML = html;
        } catch (e) {
          credentialsList.innerHTML = '<p class="hint">Unable to load credentials.</p>';
          console.error(e);
        }
      }

      // Issue credential
      issueForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        issueBtn.disabled = true;
        issueBtn.textContent = 'Issuing...';
        issueResult.innerHTML = '';

        try {
          // Get attributes based on current mode
          let attributes;
          if (currentMode === 'form') {
            attributes = FormDataCollector.collect(dynamicFormContainer);
            if (Object.keys(attributes).length === 0) {
              throw new Error('Please fill in the form fields');
            }
          } else {
            // JSON mode - parse textarea
            try {
              attributes = JSON.parse(attributesInput.value);
            } catch (err) {
              throw new Error('Invalid JSON in attributes: ' + err.message);
            }
          }

          const payload = {
            registry_name: registrySelect.value,
            schema_said: schemaSelect.value,
            attributes: attributes,
            private: privateCheck.checked,
            publish_to_witnesses: publishCheck.checked,
          };

          if (recipientInput.value.trim()) {
            payload.recipient_aid = recipientInput.value.trim();
          }

          const res = await fetch('/credential/issue', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify(payload),
          });

          const data = await res.json();

          if (!res.ok) {
            throw new Error(data.detail || 'Failed to issue credential');
          }

          issueResult.innerHTML = `
            <div class="success">
              <strong>Credential Issued Successfully!</strong>
              <div class="result-field">
                <strong>Credential SAID:</strong>
                <code>${data.credential.said}</code>
              </div>
              <div class="result-field">
                <strong>Status:</strong>
                <code>${data.credential.status}</code>
              </div>
              <div class="result-field">
                <strong>Issued At:</strong>
                <code>${data.credential.issuance_dt}</code>
              </div>
            </div>
          `;

          // Refresh the list
          loadCredentials();

          // Clear form
          attributesInput.value = '';
          recipientInput.value = '';
          privateCheck.checked = false;

          // Reset dynamic form if in form mode
          if (currentMode === 'form' && schemaSelect.value) {
            SchemaFormGenerator.generateFromSchema(schemaSelect.value, dynamicFormContainer);
          }

        } catch (err) {
          issueResult.innerHTML = `<div class="error"><strong>Error:</strong> ${err.message}</div>`;
        } finally {
          issueBtn.disabled = false;
          issueBtn.textContent = 'Issue Credential';
        }
      });

      // Revoke credential
      async function revokeCredential(said) {
        if (!confirm(`Are you sure you want to revoke credential ${said.substring(0, 16)}...?`)) {
          return;
        }

        try {
          const res = await fetch(`/credential/${said}/revoke`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({ publish_to_witnesses: true }),
          });

          if (!res.ok) {
            const data = await res.json();
            throw new Error(data.detail || 'Failed to revoke credential');
          }

          alert('Credential revoked successfully');
          loadCredentials();
        } catch (err) {
          alert('Error: ' + err.message);
        }
      }

      // Initialize
      loadRegistries();
      loadSchemas();
      loadCredentials();
    </script>
    <script src="/static/shared.js"></script>
  </body>
</html>
