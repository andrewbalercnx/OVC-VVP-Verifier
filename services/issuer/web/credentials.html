<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VVP Issuer - Credentials</title>
    <link rel="stylesheet" href="/static/styles.css">
    <link rel="icon" href="/static/favicon.ico" type="image/x-icon">
    <style>
      /* Page-specific styles for dynamic form */
      button.danger { background: #e74c3c; }
      button.danger:hover { background: #c0392b; }
      .hint { font-size: 0.875rem; color: #666; margin-top: 0.25rem; }

      /* Dynamic form fields */
      .dynamic-form .form-group { margin-bottom: 1rem; }
      .dynamic-form label { display: block; margin-bottom: 0.25rem; font-weight: 500; font-size: 0.9rem; }
      .dynamic-form .field-hint { font-size: 0.8rem; color: #888; margin-top: 0.15rem; }
      .dynamic-form input[type="text"],
      .dynamic-form input[type="number"],
      .dynamic-form input[type="datetime-local"],
      .dynamic-form select {
        width: 100%;
        padding: 0.6rem;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.95rem;
        box-sizing: border-box;
      }
      .dynamic-form input:focus, .dynamic-form select:focus {
        outline: none;
        border-color: var(--vvp-primary);
        box-shadow: 0 0 0 2px rgba(52,152,219,0.2);
      }
      .dynamic-form .checkbox-field { display: flex; align-items: center; gap: 0.5rem; }
      .dynamic-form .checkbox-field input { width: auto; }
      .dynamic-form .checkbox-field label { margin: 0; font-weight: normal; }

      /* Array fields */
      .array-field {
        border: 1px solid #e9ecef;
        border-radius: 4px;
        padding: 1rem;
        background: #fafafa;
        margin-top: 0.25rem;
      }

      /* Edges styles (Sprint 40) */
      .edges-list { margin-bottom: 0.5rem; }
      .edge-item {
        display: grid;
        grid-template-columns: 150px 1fr auto;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
        padding: 0.5rem;
        background: #f8f9fa;
        border-radius: 4px;
        align-items: center;
      }
      .edge-item select, .edge-item input {
        padding: 0.4rem;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.9rem;
      }
      .edge-item .remove-edge {
        background: #e74c3c;
        color: white;
        border: none;
        padding: 0.4rem 0.6rem;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.8rem;
      }
      .edge-item .remove-edge:hover { background: #c0392b; }
      .hint-inline { font-weight: normal; font-size: 0.85rem; color: #666; }
      .btn-small { padding: 0.4rem 0.8rem; font-size: 0.85rem; }
      .btn-secondary { background: #6c757d; }
      .btn-secondary:hover { background: #5a6268; }
      .array-item { display: flex; gap: 0.5rem; margin-bottom: 0.5rem; align-items: center; }
      .array-item input { flex: 1; }
      .array-item button { padding: 0.4rem 0.6rem; font-size: 0.8rem; background: #e74c3c; }
      .array-item button:hover { background: #c0392b; }
      .add-array-item { background: #27ae60; padding: 0.4rem 0.8rem; font-size: 0.85rem; margin-top: 0.5rem; }
      .add-array-item:hover { background: #219a52; }

      /* Schema-driven edge slots (Sprint 65) */
      .schema-edge-slot {
        border: 1px solid #e9ecef;
        border-radius: 6px;
        margin-bottom: 0.75rem;
        overflow: hidden;
      }
      .schema-edge-header {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.6rem 0.75rem;
        background: #f8f9fa;
        cursor: pointer;
        user-select: none;
      }
      .schema-edge-header:hover { background: #eef1f4; }
      .schema-edge-chevron {
        font-size: 0.7rem;
        transition: transform 0.2s;
        color: #666;
      }
      .schema-edge-slot.expanded .schema-edge-chevron { transform: rotate(90deg); }
      .schema-edge-name { font-weight: 600; font-size: 0.9rem; }
      .schema-edge-desc { font-size: 0.8rem; color: #666; flex: 1; }
      .badge-required {
        font-size: 0.65rem;
        font-weight: 600;
        padding: 0.1rem 0.4rem;
        border-radius: 3px;
        text-transform: uppercase;
      }
      .badge-required.required { background: #fde8e8; color: #e74c3c; }
      .badge-required.optional { background: #eaf4e8; color: #27ae60; }
      .schema-edge-selected {
        font-size: 0.75rem;
        color: #27ae60;
        font-weight: 500;
      }
      .schema-edge-body {
        display: none;
        padding: 0.75rem;
        border-top: 1px solid #e9ecef;
      }
      .schema-edge-slot.expanded .schema-edge-body { display: block; }
      .schema-edge-slot.deep-link-highlight {
        border-color: #0d6efd;
        box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.25);
        transition: box-shadow 0.3s ease;
      }
      .edge-meta-row {
        display: flex;
        gap: 1rem;
        font-size: 0.8rem;
        color: #666;
        margin-bottom: 0.5rem;
      }
      .edge-meta-row code {
        font-size: 0.75rem;
        background: #f0f0f0;
        padding: 0.1rem 0.3rem;
        border-radius: 2px;
      }
      .edge-candidate {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.4rem 0.5rem;
        border: 1px solid #e9ecef;
        border-radius: 4px;
        margin-bottom: 0.3rem;
        cursor: pointer;
        font-size: 0.85rem;
      }
      .edge-candidate:hover { background: #f0f7ff; border-color: #3498db; }
      .edge-candidate.selected { background: #e8f4fd; border-color: #3498db; }
      .edge-candidate input[type="radio"] { margin: 0; }
      .edge-candidate .cred-said { font-family: monospace; font-size: 0.8rem; color: #555; }
      .edge-candidate .cred-type { font-size: 0.75rem; color: #3498db; font-weight: 500; }
      .edge-candidate .cred-preview { font-size: 0.75rem; color: #888; }
      .edge-no-candidates { font-size: 0.85rem; color: #999; font-style: italic; padding: 0.5rem 0; }
      .edge-org-warning {
        font-size: 0.8rem;
        color: #e67e22;
        background: #fef5e7;
        padding: 0.4rem 0.6rem;
        border-radius: 4px;
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
      }
      .edge-org-select {
        font-size: 0.8rem;
        padding: 0.2rem 0.4rem;
        border-radius: 4px;
        border: 1px solid #e67e22;
      }

      /* Credential type cards (Sprint 65) */
      .credential-type-cards {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-bottom: 1rem;
      }
      .cred-type-card {
        padding: 0.5rem 0.75rem;
        border: 1px solid #e9ecef;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.85rem;
        background: #fff;
        transition: all 0.15s;
      }
      .cred-type-card:hover { border-color: #3498db; background: #f0f7ff; }
      .cred-type-card.active { border-color: #3498db; background: #e8f4fd; font-weight: 600; }
      .cred-type-card .card-label { font-weight: 500; }
      .cred-type-card .card-desc { font-size: 0.75rem; color: #888; }

      /* Dossier context banner */
      .dossier-context-banner {
        background: #e8f4fd;
        border: 1px solid #3498db;
        border-radius: 4px;
        padding: 0.5rem 0.75rem;
        margin-bottom: 1rem;
        font-size: 0.85rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .dossier-context-banner a { color: #3498db; font-weight: 500; }

      /* Nested objects */
      .nested-object {
        border: 1px solid var(--vvp-border);
        border-radius: 4px;
        padding: 1rem;
        margin-top: 0.5rem;
        background: #fcfcfc;
      }
      .nested-object-title {
        font-weight: 500;
        margin-bottom: 0.75rem;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid #eee;
        color: var(--vvp-text);
      }
      .required-indicator { color: #e74c3c; margin-left: 2px; }

      /* GLEIF LEI display styles */
      .subject-cell { max-width: 280px; }
      .lei-subject {
        display: flex;
        flex-direction: column;
        gap: 0.15rem;
      }
      .lei-subject strong {
        color: var(--vvp-text, #2c3e50);
        font-size: 0.9rem;
      }
      .gleif-badge {
        display: inline-block;
        font-size: 0.65rem;
        font-weight: 600;
        padding: 0.1rem 0.35rem;
        background: #27ae60;
        color: white;
        border-radius: 3px;
        margin-left: 0.35rem;
        vertical-align: middle;
      }
      .lei-link {
        font-size: 0.75rem;
        color: #3498db;
        text-decoration: none;
        font-family: monospace;
      }
      .lei-link:hover { text-decoration: underline; }
      .tn-subject {
        font-family: monospace;
        font-size: 0.85rem;
        color: var(--vvp-text, #2c3e50);
      }
      .channel-badge {
        display: inline-block;
        font-size: 0.7rem;
        padding: 0.1rem 0.4rem;
        background: #3498db;
        color: white;
        border-radius: 3px;
        margin-left: 0.35rem;
        text-transform: uppercase;
      }
    </style>
  </head>
  <body>
    <header class="site-header">
      <div class="header-brand">
        <img src="/static/ovc-logo.png" alt="OVC" class="ovc-logo">
        <a href="/ui/" class="logo">
          <span class="service-label">VVP</span>
          Issuer
        </a>
      </div>
      <nav class="nav-links">
        <a href="/ui/identity">Identities</a>
        <a href="/ui/registry">Registries</a>
        <a href="/ui/schemas">Schemas</a>
        <a href="/ui/credentials" class="active">Credentials</a>
        <a href="/ui/dossier">Dossiers</a>
        <a href="/ui/vvp">VVP Headers</a>
        <a href="/ui/tn-mappings">TN Mappings</a>
        <a href="/ui/help">Help</a>
        <a href="/ui/admin">Admin</a>
        <a href="/organizations/ui" style="display:none">Organizations</a>
        <a href="https://vvp-verifier.rcnx.io" class="verifier-link" target="_blank">Verifier ↗</a>
      </nav>
    </header>

    <h1>Credential Management</h1>
    <p class="subtitle">Issue and manage ACDC credentials</p>

    <!-- Dossier context banner (Sprint 65 - shown when linked from dossier wizard) -->
    <div id="dossierContextBanner" class="dossier-context-banner" style="display:none">
      <span>Creating credential for dossier edge:</span>
      <strong id="dossierEdgeName"></strong>
      <span style="flex:1"></span>
      <a href="/ui/dossier">Return to Dossier Wizard</a>
    </div>

    <!-- Issue Credential Form -->
    <div class="card">
      <h2>Issue Credential</h2>
      <form id="issueForm">
        <!-- VVP Credential Type Cards (Sprint 65) -->
        <div id="credentialTypeCards" class="credential-type-cards">
          <!-- Populated dynamically from schema list -->
        </div>

        <div class="form-group">
          <label for="registry">Registry</label>
          <select id="registry" required>
            <option value="">Loading registries...</option>
          </select>
        </div>

        <div class="form-group">
          <label for="schema">Schema</label>
          <select id="schema" required>
            <option value="">Loading schemas...</option>
          </select>
        </div>

        <div class="form-group">
          <label>Attributes</label>
          <div class="tabs" id="inputModeTabs">
            <button type="button" class="tab active" data-mode="form">Form Mode</button>
            <button type="button" class="tab" data-mode="json">Advanced (JSON)</button>
          </div>
          <div id="formModePanel" class="tab-panel active">
            <div id="dynamicFormContainer" class="dynamic-form">
              <p class="hint">Select a schema to see the form fields</p>
            </div>
          </div>
          <div id="jsonModePanel" class="tab-panel">
            <textarea id="attributes" placeholder='{"numbers": {"tn": ["+12025551234"]}, "channel": "voice", "doNotOriginate": false}'></textarea>
            <p class="hint">Enter the credential attributes as valid JSON. The structure depends on the selected schema.</p>
          </div>
        </div>

        <div class="form-group">
          <label for="recipient">Recipient AID (optional)</label>
          <div style="display:flex; gap:0.5rem; align-items:center;">
            <input type="text" id="recipient" placeholder="Leave empty for untargeted credential" style="flex:1"/>
            <select id="recipientOrgPicker" style="width:auto; min-width:150px; padding:0.6rem; border:1px solid #ddd; border-radius:4px; font-size:0.9rem;">
              <option value="">Or pick org...</option>
            </select>
          </div>
        </div>

        <!-- Schema-Driven Edges (Sprint 65) -->
        <div id="schemaEdgesContainer" class="form-group" style="display:none">
          <label>Credential Edges <span class="hint-inline">(from schema definition)</span></label>
          <div id="schemaEdgeSlots"></div>
        </div>

        <!-- Manual Edges Section (Sprint 40 — fallback for custom/undefined edges) -->
        <div class="form-group" id="manualEdgesGroup">
          <label>Additional Edges <span class="hint-inline">Link to other credentials manually</span></label>
          <div id="edgesContainer">
            <div class="edges-list" id="edgesList"></div>
            <button type="button" class="btn-secondary btn-small" id="addEdgeBtn">+ Add Edge</button>
          </div>
          <p class="hint">
            Use for edge types not defined in the schema. Schema-defined edges are shown above when a schema is selected.
          </p>
        </div>

        <div class="checkbox-row">
          <input type="checkbox" id="private"/>
          <label for="private">Add privacy-preserving nonces</label>
        </div>

        <div class="checkbox-row">
          <input type="checkbox" id="publishWitnesses" checked/>
          <label for="publishWitnesses">Publish to witnesses</label>
        </div>

        <button type="submit" id="issueBtn">Issue Credential</button>
      </form>

      <div id="issueResult"></div>
    </div>

    <!-- Credentials List - Org User View -->
    <div class="card" id="issuedCredentialsCard">
      <h2>Issued by Your Organization</h2>
      <div id="issuedCredentialsList">
        <p class="loading">Loading credentials...</p>
      </div>
    </div>

    <div class="card" id="subjectCredentialsCard">
      <h2>Issued to Your Organization</h2>
      <div id="subjectCredentialsList">
        <p class="loading">Loading credentials...</p>
      </div>
    </div>

    <!-- Credentials List - Admin View -->
    <div class="card" id="allCredentialsCard" style="display:none">
      <h2>All Credentials</h2>
      <div id="allCredentialsList">
        <p class="loading">Loading credentials...</p>
      </div>
    </div>

    <!-- Datalist for credential SAIDs (for edge picker) -->
    <datalist id="credentialSaidList"></datalist>

    <script src="/static/shared.js"></script>
    <script>
      const registrySelect = document.getElementById('registry');
      const schemaSelect = document.getElementById('schema');
      const attributesInput = document.getElementById('attributes');
      const recipientInput = document.getElementById('recipient');
      const privateCheck = document.getElementById('private');
      const publishCheck = document.getElementById('publishWitnesses');
      const issueForm = document.getElementById('issueForm');
      const issueBtn = document.getElementById('issueBtn');
      const issueResult = document.getElementById('issueResult');
      const issuedCredentialsList = document.getElementById('issuedCredentialsList');
      const subjectCredentialsList = document.getElementById('subjectCredentialsList');
      const allCredentialsList = document.getElementById('allCredentialsList');
      const dynamicFormContainer = document.getElementById('dynamicFormContainer');
      const formModePanel = document.getElementById('formModePanel');
      const jsonModePanel = document.getElementById('jsonModePanel');
      const modeTabs = document.querySelectorAll('#inputModeTabs .tab');
      const edgesList = document.getElementById('edgesList');
      const addEdgeBtn = document.getElementById('addEdgeBtn');

      // Track current input mode
      let currentMode = 'form';
      let currentSchemaDoc = null;
      let availableCredentials = [];

      // Sprint 65: Schema-driven edge state
      const schemaEdgeSelections = new Map(); // edgeName → selected credential SAID
      let currentEdgeSlots = [];              // parsed edge slot definitions
      const schemaLabelMap = new Map();        // schema SAID → human-readable title
      const credDetailCache = {};             // credential SAID → detail response
      let edgeOrgContext = null;              // org ID for edge candidate loading
      const schemaEdgeSlotsContainer = document.getElementById('schemaEdgeSlots');
      const schemaEdgesContainer = document.getElementById('schemaEdgesContainer');
      const recipientOrgPicker = document.getElementById('recipientOrgPicker');
      const credentialTypeCardsContainer = document.getElementById('credentialTypeCards');

      // VVP credential type card definitions (matched by schema title)
      const VVP_CREDENTIAL_TYPES = [
        { match: 'TN Allocation', label: 'TN Allocation', description: 'Phone number allocation', order: 1 },
        { match: 'Cooperative Delegation', label: 'Delegated Signer', description: 'Delegation credential', order: 2 },
        { match: 'Legal Entity', label: 'Legal Entity', description: 'Organization identity', order: 3 },
        { match: 'Brand', label: 'Brand Credential', description: 'Brand ownership', order: 4 },
        { match: 'Vetter Certification', label: 'Vetter Cert', description: 'Vetter authority', order: 5 },
      ];

      // =====================================================================
      // GLEIF LEI Lookup Service
      // =====================================================================
      const GleifService = {
        cache: new Map(),
        pendingRequests: new Map(),

        /**
         * Look up a Legal Entity Identifier (LEI) via the GLEIF API.
         * @param {string} lei - The 20-character LEI
         * @returns {Promise<{legalName: string, country: string, lei: string} | null>}
         */
        async lookup(lei) {
          if (!lei || lei.length !== 20) return null;

          // Check cache first
          if (this.cache.has(lei)) {
            return this.cache.get(lei);
          }

          // Deduplicate concurrent requests for the same LEI
          if (this.pendingRequests.has(lei)) {
            return this.pendingRequests.get(lei);
          }

          const promise = this._fetchLei(lei);
          this.pendingRequests.set(lei, promise);

          try {
            const result = await promise;
            this.cache.set(lei, result);
            return result;
          } finally {
            this.pendingRequests.delete(lei);
          }
        },

        async _fetchLei(lei) {
          try {
            const res = await fetch(`https://api.gleif.org/api/v1/lei-records/${lei}`);
            if (!res.ok) return null;

            const data = await res.json();
            const entity = data.data?.attributes?.entity;
            if (!entity) return null;

            return {
              lei: lei,
              legalName: entity.legalName?.name || null,
              country: entity.legalAddress?.country || null,
              tradingName: entity.otherNames?.find(n => n.type === 'TRADING_OR_OPERATING_NAME')?.name || null,
            };
          } catch (e) {
            console.warn(`GLEIF lookup failed for ${lei}:`, e);
            return null;
          }
        },

        /**
         * Look up multiple LEIs and return results keyed by LEI.
         * @param {string[]} leis - Array of LEI strings
         * @returns {Promise<Map<string, object>>}
         */
        async lookupMany(leis) {
          const results = new Map();
          const uniqueLeis = [...new Set(leis.filter(Boolean))];

          await Promise.all(
            uniqueLeis.map(async (lei) => {
              const info = await this.lookup(lei);
              if (info) results.set(lei, info);
            })
          );

          return results;
        }
      };

      // Common edge types for dropdown
      const EDGE_TYPES = [
        { value: 'certification', label: 'certification (→Vetter Cert)' },
        { value: 'vetting', label: 'vetting (APE→LE)' },
        { value: 'delegation', label: 'delegation (DE→APE/DE)' },
        { value: 'jl', label: 'jl (TN→LE)' },
        { value: 'le', label: 'le (→Legal Entity)' },
        { value: 'custom', label: 'custom...' },
      ];

      // Edge management functions
      function createEdgeRow() {
        const row = document.createElement('div');
        row.className = 'edge-item';

        // Edge type selector
        const typeSelect = document.createElement('select');
        typeSelect.className = 'edge-type';
        typeSelect.innerHTML = EDGE_TYPES.map(t =>
          `<option value="${t.value}">${t.label}</option>`
        ).join('');

        // Custom type input (hidden by default)
        const customInput = document.createElement('input');
        customInput.type = 'text';
        customInput.className = 'edge-custom-type';
        customInput.placeholder = 'Edge name';
        customInput.style.display = 'none';

        typeSelect.addEventListener('change', () => {
          customInput.style.display = typeSelect.value === 'custom' ? 'block' : 'none';
        });

        // Target SAID input/select
        const targetInput = document.createElement('input');
        targetInput.type = 'text';
        targetInput.className = 'edge-target';
        targetInput.placeholder = 'Target credential SAID';
        targetInput.list = 'credentialSaidList';

        // Remove button
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'remove-edge';
        removeBtn.textContent = '✕';
        removeBtn.onclick = () => row.remove();

        row.appendChild(typeSelect);
        row.appendChild(customInput);
        row.appendChild(targetInput);
        row.appendChild(removeBtn);

        return row;
      }

      function collectEdges() {
        const edges = {};

        // 1. Collect schema-driven edge selections (Sprint 65) — takes precedence
        schemaEdgeSelections.forEach((said, edgeName) => {
          if (said) {
            const slot = currentEdgeSlots.find(s => s.name === edgeName);
            const cred = availableCredentials.find(c => c.said === said);
            const entry = {
              n: said,
              s: slot?.schemaConstraint || cred?.schema_said || '',
            };
            if (slot?.operator) entry.o = slot.operator;
            edges[edgeName] = entry;
          }
        });

        // 2. Collect manual edges (only for names NOT already set by schema)
        const rows = edgesList.querySelectorAll('.edge-item');
        rows.forEach(row => {
          const typeSelect = row.querySelector('.edge-type');
          const customInput = row.querySelector('.edge-custom-type');
          const targetInput = row.querySelector('.edge-target');

          const edgeType = typeSelect.value === 'custom' ? customInput.value : typeSelect.value;
          const targetSaid = targetInput.value.trim();

          if (edgeType && targetSaid && !edges[edgeType]) {
            const targetCred = availableCredentials.find(c => c.said === targetSaid);
            edges[edgeType] = {
              n: targetSaid,
              s: targetCred?.schema_said || ''
            };
          }
        });

        return Object.keys(edges).length > 0 ? edges : null;
      }

      // Add edge button handler
      addEdgeBtn.addEventListener('click', () => {
        edgesList.appendChild(createEdgeRow());
      });

      // System fields to skip (auto-populated by backend)
      const SYSTEM_FIELDS = ['d', 'u', 'i', 'dt'];

      // Tab switching
      modeTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const mode = tab.dataset.mode;
          if (mode === currentMode) return;

          // Sync data before switching
          if (currentMode === 'form' && mode === 'json') {
            // Form -> JSON: collect form data to textarea
            const formData = FormDataCollector.collect(dynamicFormContainer);
            if (Object.keys(formData).length > 0) {
              attributesInput.value = JSON.stringify(formData, null, 2);
            }
          }

          // Update tab styling
          modeTabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');

          // Show/hide panels
          formModePanel.classList.toggle('active', mode === 'form');
          jsonModePanel.classList.toggle('active', mode === 'json');
          currentMode = mode;
        });
      });

      // Schema Form Generator
      class SchemaFormGenerator {
        static async generateFromSchema(said, container) {
          container.innerHTML = '<p class="hint">Loading schema...</p>';

          try {
            const res = await authFetch(`/schema/${said}`);
            if (!res.ok) throw new Error('Failed to load schema');
            const schema = await res.json();

            currentSchemaDoc = schema.schema_document;
            if (!currentSchemaDoc) {
              container.innerHTML = '<p class="hint">Schema has no document - use JSON mode</p>';
              return;
            }

            // Extract attributes schema from properties.a.oneOf[1] (the object variant)
            const attrSchema = this.extractAttributesSchema(currentSchemaDoc);
            if (!attrSchema || !attrSchema.properties) {
              container.innerHTML = '<p class="hint">Could not extract attributes schema - use JSON mode</p>';
              return;
            }

            // Generate form fields
            container.innerHTML = '';
            this.renderFields(attrSchema, container, '');

          } catch (e) {
            console.error('Schema generation error:', e);
            container.innerHTML = `<p class="error">Error loading schema: ${e.message}</p>`;
          }
        }

        static extractAttributesSchema(schemaDoc) {
          // Try properties.a.oneOf[1] first (standard ACDC structure)
          if (schemaDoc.properties?.a?.oneOf) {
            const objVariant = schemaDoc.properties.a.oneOf.find(v => v.type === 'object');
            if (objVariant) return objVariant;
          }
          // Fallback: properties.a directly if it's an object schema
          if (schemaDoc.properties?.a?.type === 'object') {
            return schemaDoc.properties.a;
          }
          // Last resort: the schema itself
          return schemaDoc;
        }

        static renderFields(schema, container, pathPrefix) {
          const required = schema.required || [];

          for (const [key, prop] of Object.entries(schema.properties || {})) {
            // Skip system fields
            if (SYSTEM_FIELDS.includes(key)) continue;

            const path = pathPrefix ? `${pathPrefix}.${key}` : key;
            const isRequired = required.includes(key);

            if (prop.type === 'object' && prop.properties) {
              // Nested object
              this.renderNestedObject(key, prop, container, path, isRequired);
            } else if (prop.type === 'array') {
              // Array field
              this.renderArrayField(key, prop, container, path, isRequired);
            } else {
              // Simple field
              this.renderSimpleField(key, prop, container, path, isRequired);
            }
          }
        }

        static renderSimpleField(key, prop, container, path, isRequired) {
          const group = document.createElement('div');
          group.className = 'form-group';

          const label = document.createElement('label');
          label.textContent = prop.title || this.formatLabel(key);
          if (isRequired) {
            const req = document.createElement('span');
            req.className = 'required-indicator';
            req.textContent = '*';
            label.appendChild(req);
          }

          let input;

          // Determine input type based on schema
          if (prop.pattern && (prop.pattern.includes('|'))) {
            // Pattern with alternatives - use select
            input = document.createElement('select');
            const options = prop.pattern.split('|').map(o => o.replace(/[^a-zA-Z0-9]/g, ''));
            const emptyOpt = document.createElement('option');
            emptyOpt.value = '';
            emptyOpt.textContent = `Select ${this.formatLabel(key)}...`;
            input.appendChild(emptyOpt);
            for (const opt of options) {
              const option = document.createElement('option');
              option.value = opt;
              option.textContent = opt;
              input.appendChild(option);
            }
          } else if (prop.format === 'date-time') {
            input = document.createElement('input');
            input.type = 'datetime-local';
          } else if (prop.type === 'boolean') {
            // Checkbox
            group.className = 'form-group checkbox-field';
            input = document.createElement('input');
            input.type = 'checkbox';
            input.id = `field_${path.replace(/\./g, '_')}`;
            label.setAttribute('for', input.id);
          } else if (prop.type === 'integer' || prop.type === 'number') {
            input = document.createElement('input');
            input.type = 'number';
            if (prop.minimum !== undefined) input.min = prop.minimum;
            if (prop.maximum !== undefined) input.max = prop.maximum;
          } else {
            input = document.createElement('input');
            input.type = 'text';
            if (prop.pattern) input.pattern = prop.pattern;
          }

          input.dataset.path = path;
          input.dataset.type = prop.type || 'string';
          if (isRequired && prop.type !== 'boolean') input.required = true;
          if (prop.default !== undefined && prop.type !== 'boolean') input.value = prop.default;
          if (prop.type === 'boolean' && prop.default === true) input.checked = true;

          if (prop.type === 'boolean') {
            group.appendChild(input);
            group.appendChild(label);
          } else {
            group.appendChild(label);
            group.appendChild(input);
          }

          // Add description hint
          if (prop.description) {
            const hint = document.createElement('p');
            hint.className = 'field-hint';
            hint.textContent = prop.description;
            group.appendChild(hint);
          }

          container.appendChild(group);
        }

        static renderArrayField(key, prop, container, path, isRequired) {
          const group = document.createElement('div');
          group.className = 'form-group';

          const label = document.createElement('label');
          label.textContent = prop.title || this.formatLabel(key);
          if (isRequired) {
            const req = document.createElement('span');
            req.className = 'required-indicator';
            req.textContent = '*';
            label.appendChild(req);
          }
          group.appendChild(label);

          const arrayContainer = document.createElement('div');
          arrayContainer.className = 'array-field';
          arrayContainer.dataset.path = path;
          arrayContainer.dataset.type = 'array';

          const itemsContainer = document.createElement('div');
          itemsContainer.className = 'array-items';

          // Add initial item
          this.addArrayItem(itemsContainer, prop.items || {}, path);

          arrayContainer.appendChild(itemsContainer);

          // Add button
          const addBtn = document.createElement('button');
          addBtn.type = 'button';
          addBtn.className = 'add-array-item';
          addBtn.textContent = '+ Add';
          addBtn.onclick = () => this.addArrayItem(itemsContainer, prop.items || {}, path);
          arrayContainer.appendChild(addBtn);

          group.appendChild(arrayContainer);
          container.appendChild(group);
        }

        static addArrayItem(container, itemSchema, basePath) {
          const idx = container.children.length;
          const itemDiv = document.createElement('div');
          itemDiv.className = 'array-item';

          const input = document.createElement('input');
          input.type = 'text';
          input.dataset.path = `${basePath}[${idx}]`;
          input.dataset.type = itemSchema.type || 'string';
          if (itemSchema.pattern) input.pattern = itemSchema.pattern;
          if (itemSchema.format === 'phone') input.placeholder = '+12025551234';

          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.textContent = '×';
          removeBtn.onclick = () => {
            itemDiv.remove();
            this.reindexArrayItems(container, basePath);
          };

          itemDiv.appendChild(input);
          itemDiv.appendChild(removeBtn);
          container.appendChild(itemDiv);
        }

        static reindexArrayItems(container, basePath) {
          const items = container.querySelectorAll('.array-item input');
          items.forEach((input, idx) => {
            input.dataset.path = `${basePath}[${idx}]`;
          });
        }

        static renderNestedObject(key, prop, container, path, isRequired) {
          const group = document.createElement('div');
          group.className = 'form-group';

          const nested = document.createElement('div');
          nested.className = 'nested-object';

          const title = document.createElement('div');
          title.className = 'nested-object-title';
          title.textContent = prop.title || this.formatLabel(key);
          if (isRequired) {
            const req = document.createElement('span');
            req.className = 'required-indicator';
            req.textContent = ' *';
            title.appendChild(req);
          }
          nested.appendChild(title);

          // Render nested fields
          this.renderFields(prop, nested, path);

          group.appendChild(nested);
          container.appendChild(group);
        }

        static formatLabel(key) {
          // Convert camelCase to Title Case
          return key
            .replace(/([A-Z])/g, ' $1')
            .replace(/^./, str => str.toUpperCase())
            .trim();
        }
      }

      // Form Data Collector
      class FormDataCollector {
        static collect(container) {
          const data = {};
          const inputs = container.querySelectorAll('[data-path]');

          inputs.forEach(input => {
            const path = input.dataset.path;
            const type = input.dataset.type;

            let value;
            if (input.type === 'checkbox') {
              value = input.checked;
            } else if (type === 'integer') {
              value = input.value ? parseInt(input.value, 10) : undefined;
            } else if (type === 'number') {
              value = input.value ? parseFloat(input.value) : undefined;
            } else if (type === 'boolean') {
              value = input.checked;
            } else {
              value = input.value || undefined;
            }

            // Skip empty values (except booleans)
            if (value === undefined || value === '') return;

            this.setNestedValue(data, path, value);
          });

          return data;
        }

        static setNestedValue(obj, path, value) {
          // Parse path like "numbers.tn[0]" or "channel"
          const parts = path.match(/[^.\[\]]+|\[\d+\]/g) || [];

          let current = obj;
          for (let i = 0; i < parts.length - 1; i++) {
            let part = parts[i];
            const nextPart = parts[i + 1];

            // Handle array index
            if (part.startsWith('[')) {
              part = parseInt(part.slice(1, -1), 10);
            }

            // Determine if next level is array or object
            const nextIsArray = nextPart && nextPart.startsWith('[');

            if (current[part] === undefined) {
              current[part] = nextIsArray ? [] : {};
            }
            current = current[part];
          }

          // Set the final value
          let finalPart = parts[parts.length - 1];
          if (finalPart.startsWith('[')) {
            finalPart = parseInt(finalPart.slice(1, -1), 10);
          }
          current[finalPart] = value;
        }
      }

      // =====================================================================
      // Schema Edge Parser (Sprint 65)
      // Parses edge definitions from schema JSON, mirroring SchemaFormGenerator
      // for attributes but targeting the edges block (properties.e.oneOf).
      // =====================================================================
      class SchemaEdgeParser {
        /**
         * Parse edge slot definitions from a schema document.
         * @param {Object} schemaDoc - Full schema JSON document
         * @returns {Array<{name, required, schemaConstraint, operator, description}>}
         */
        static parseEdges(schemaDoc) {
          if (!schemaDoc?.properties?.e?.oneOf) return [];

          // Find the object variant by type (NOT by index)
          const edgesObj = schemaDoc.properties.e.oneOf.find(v => v.type === 'object');
          if (!edgesObj || !edgesObj.properties) return [];

          const requiredEdges = new Set((edgesObj.required || []).filter(k => k !== 'd'));
          const slots = [];

          for (const [key, prop] of Object.entries(edgesObj.properties)) {
            if (key === 'd') continue; // Skip SAID field
            slots.push({
              name: key,
              required: requiredEdges.has(key),
              schemaConstraint: prop.properties?.s?.const || null,
              operator: prop.properties?.o?.const || null,
              description: prop.description || '',
            });
          }

          // Sort: required first, then alphabetical
          slots.sort((a, b) => {
            if (a.required !== b.required) return a.required ? -1 : 1;
            return a.name.localeCompare(b.name);
          });

          return slots;
        }
      }

      // =====================================================================
      // Schema-Driven Edge UI (Sprint 65)
      // =====================================================================

      /**
       * Render schema-driven edge slots when a schema is selected.
       */
      function renderSchemaEdgeSlots(edgeSlots) {
        schemaEdgeSelections.clear();
        currentEdgeSlots = edgeSlots;

        if (!edgeSlots || edgeSlots.length === 0) {
          schemaEdgesContainer.style.display = 'none';
          schemaEdgeSlotsContainer.innerHTML = '';
          return;
        }

        schemaEdgesContainer.style.display = '';
        let html = '';

        for (const slot of edgeSlots) {
          const safeName = sanitizeEdgeName(slot.name);
          const badgeClass = slot.required ? 'required' : 'optional';
          const badgeText = slot.required ? 'Required' : 'Optional';
          const schemaLabel = slot.schemaConstraint ? (schemaLabelMap.get(slot.schemaConstraint) || slot.schemaConstraint.substring(0, 12) + '...') : 'Any';
          const operatorDisplay = slot.operator || 'None';
          const nameFormatted = formatLabel(slot.name);

          html += `
            <div class="schema-edge-slot" data-edge="${escapeHtml(slot.name)}">
              <div class="schema-edge-header" data-toggle-edge="${safeName}" data-edge-name="${escapeHtml(slot.name)}">
                <span class="schema-edge-chevron">&#9654;</span>
                <span class="schema-edge-name">${escapeHtml(nameFormatted)}</span>
                <span class="schema-edge-desc">${escapeHtml(slot.description.substring(0, 80))}</span>
                <span class="badge-required ${badgeClass}">${badgeText}</span>
                <span class="schema-edge-selected" id="edgeCheck_${safeName}"></span>
              </div>
              <div class="schema-edge-body">
                <div class="edge-meta-row">
                  <span>Operator: <code>${escapeHtml(operatorDisplay)}</code></span>
                  <span>Schema: <code>${escapeHtml(schemaLabel)}</code></span>
                </div>
                <div id="edgeCandidates_${safeName}">
                  <p class="hint">Loading candidates...</p>
                </div>
              </div>
            </div>
          `;
        }

        schemaEdgeSlotsContainer.innerHTML = html;

        // Bind toggle handlers via event delegation (no inline onclick)
        schemaEdgeSlotsContainer.querySelectorAll('[data-toggle-edge]').forEach(header => {
          header.addEventListener('click', () => {
            const name = header.dataset.toggleEdge;
            const slotEl = header.closest('.schema-edge-slot');
            if (slotEl) slotEl.classList.toggle('expanded');
          });
        });

        // Load candidates for each slot
        for (const slot of edgeSlots) {
          loadEdgeCandidates(slot);
        }
      }

      /**
       * Populate an org selector dropdown for I2I edge slots (admin flow).
       */
      async function loadEdgeOrgOptions(selectEl) {
        if (!selectEl) return;
        try {
          const res = await authFetch('/organizations/names');
          if (!res.ok) return;
          const data = await res.json();
          for (const org of (data.organizations || [])) {
            const option = document.createElement('option');
            option.value = org.id;
            option.textContent = org.name;
            selectEl.appendChild(option);
          }
        } catch (e) {
          console.warn('Failed to load orgs for edge selector:', e);
        }
      }

      /**
       * Set org context from I2I edge selector and reload all edge candidates.
       */
      function setEdgeOrgContext(orgId) {
        if (!orgId) return;
        edgeOrgContext = orgId;
        // Reload all edge slot candidates with new org context
        if (currentEdgeSlots) {
          for (const slot of currentEdgeSlots) {
            loadEdgeCandidates(slot);
          }
        }
      }

      /**
       * Load credential candidates for an edge slot.
       */
      async function loadEdgeCandidates(slot) {
        const container = document.getElementById(`edgeCandidates_${sanitizeEdgeName(slot.name)}`);
        if (!container) return;

        // I2I without org context: show org selector for admin
        if (slot.operator === 'I2I' && !edgeOrgContext) {
          container.innerHTML = `
            <div class="edge-org-warning">
              <span>I2I edge requires organization context.</span>
              <select class="edge-org-select">
                <option value="">Select organization...</option>
              </select>
            </div>
          `;
          // Populate org selector and bind change handler
          const selectEl = container.querySelector('.edge-org-select');
          loadEdgeOrgOptions(selectEl);
          selectEl.addEventListener('change', () => setEdgeOrgContext(selectEl.value));
          return;
        }

        try {
          const params = new URLSearchParams();
          if (slot.schemaConstraint) params.set('schema_said', slot.schemaConstraint);
          // org_id filter is admin-only; non-admin creds are already org-scoped
          if (edgeOrgContext && isSystemAdmin()) params.set('org_id', edgeOrgContext);

          const res = await authFetch(`/credential?${params}`);
          if (!res.ok) {
            container.innerHTML = '<p class="edge-no-candidates">Unable to load credentials.</p>';
            return;
          }

          let candidates = (await res.json()).credentials || [];

          // I2I filtering: only credentials issued TO the org
          if (slot.operator === 'I2I' && edgeOrgContext) {
            candidates = candidates.filter(c => c.relationship === 'subject');
          }

          // Exclude revoked
          candidates = candidates.filter(c => c.status !== 'revoked');

          if (candidates.length === 0) {
            let createHref = '';
            if (slot.schemaConstraint) {
              const linkParams = new URLSearchParams({schema: slot.schemaConstraint, context: 'dossier', edge: slot.name});
              if (edgeOrgContext) linkParams.set('org', edgeOrgContext);
              createHref = `<a href="/ui/credentials?${linkParams}">Create one</a>`;
            }
            container.innerHTML = `<p class="edge-no-candidates">No matching credentials. ${createHref}</p>`;
            return;
          }

          let html = '';
          for (const cred of candidates) {
            const typeLabel = schemaLabelMap.get(cred.schema_said) || cred.schema_said.substring(0, 12) + '...';
            const preview = await getCredPreview(cred);
            const selected = schemaEdgeSelections.get(slot.name) === cred.said;

            html += `
              <div class="edge-candidate ${selected ? 'selected' : ''}"
                   data-select-edge="${escapeHtml(slot.name)}" data-select-said="${escapeHtml(cred.said)}">
                <input type="radio" name="edge_${sanitizeEdgeName(slot.name)}" value="${escapeHtml(cred.said)}" ${selected ? 'checked' : ''}>
                <span class="cred-said">${cred.said.substring(0, 16)}...</span>
                <span class="cred-type">${escapeHtml(typeLabel)}</span>
                <span class="cred-preview">${escapeHtml(preview)}</span>
              </div>
            `;
          }
          container.innerHTML = html;

          // Bind selection handlers via event delegation (no inline onclick)
          container.querySelectorAll('[data-select-edge]').forEach(el => {
            el.addEventListener('click', () => {
              selectSchemaEdge(el.dataset.selectEdge, el.dataset.selectSaid);
            });
          });

        } catch (e) {
          container.innerHTML = '<p class="edge-no-candidates">Error loading candidates.</p>';
          console.error('Edge candidate load error:', e);
        }
      }

      /**
       * Get a brief preview string for a credential's key attributes.
       */
      async function getCredPreview(cred) {
        try {
          if (!credDetailCache[cred.said]) {
            const res = await authFetch(`/credential/${cred.said}`);
            if (res.ok) credDetailCache[cred.said] = await res.json();
          }
          const detail = credDetailCache[cred.said];
          if (!detail?.attributes) return '';

          const a = detail.attributes;
          // TNAlloc
          if (a.numbers?.tn) {
            const tns = Array.isArray(a.numbers.tn) ? a.numbers.tn : [a.numbers.tn];
            return tns.slice(0, 2).join(', ') + (tns.length > 2 ? '...' : '');
          }
          // LE
          if (a.legalName) return a.legalName;
          if (a.LEI) return 'LEI: ' + a.LEI;
          // Brand
          if (a.brandName) return a.brandName;
          // GCD
          if (a.role) return 'Role: ' + a.role;
          return '';
        } catch (e) {
          return '';
        }
      }

      /**
       * Select a credential for a schema-driven edge slot.
       */
      function selectSchemaEdge(edgeName, said) {
        const current = schemaEdgeSelections.get(edgeName);
        if (current === said) {
          // Deselect
          schemaEdgeSelections.delete(edgeName);
        } else {
          schemaEdgeSelections.set(edgeName, said);
        }

        // Update check mark
        const safeEdge = sanitizeEdgeName(edgeName);
        const checkEl = document.getElementById(`edgeCheck_${safeEdge}`);
        if (checkEl) {
          checkEl.textContent = schemaEdgeSelections.has(edgeName) ? '\u2713' : '';
        }

        // Update candidate selection styling
        const container = document.getElementById(`edgeCandidates_${safeEdge}`);
        if (container) {
          container.querySelectorAll('.edge-candidate').forEach(el => {
            const radio = el.querySelector('input[type="radio"]');
            const isSelected = radio.value === schemaEdgeSelections.get(edgeName);
            el.classList.toggle('selected', isSelected);
            radio.checked = isSelected;
          });
        }
      }

      /**
       * Render credential type quick-create cards.
       */
      function renderCredentialTypeCards(schemas) {
        const cards = [];
        for (const typeDef of VVP_CREDENTIAL_TYPES) {
          const matchingSchema = schemas.find(s => s.title && s.title.includes(typeDef.match));
          if (matchingSchema) {
            cards.push({ ...typeDef, said: matchingSchema.said });
          }
        }

        if (cards.length === 0) {
          credentialTypeCardsContainer.style.display = 'none';
          return;
        }

        cards.sort((a, b) => a.order - b.order);
        credentialTypeCardsContainer.innerHTML = cards.map(c => `
          <div class="cred-type-card" data-said="${escapeHtml(c.said)}">
            <div class="card-label">${escapeHtml(c.label)}</div>
            <div class="card-desc">${escapeHtml(c.description)}</div>
          </div>
        `).join('');
        // Bind click handlers via event delegation (no inline onclick)
        credentialTypeCardsContainer.querySelectorAll('.cred-type-card').forEach(card => {
          card.addEventListener('click', () => selectCredentialType(card.dataset.said));
        });
      }

      function selectCredentialType(said) {
        schemaSelect.value = said;
        schemaSelect.dispatchEvent(new Event('change'));

        // Update card active state
        credentialTypeCardsContainer.querySelectorAll('.cred-type-card').forEach(card => {
          card.classList.toggle('active', card.dataset.said === said);
        });
      }

      /**
       * Handle deep link query params from dossier wizard.
       */
      function handleDeepLinks() {
        const params = new URLSearchParams(window.location.search);

        if (params.get('context') === 'dossier') {
          const banner = document.getElementById('dossierContextBanner');
          banner.style.display = 'flex';
          const edgeName = params.get('edge');
          if (edgeName) {
            document.getElementById('dossierEdgeName').textContent = formatLabel(edgeName);
            // Store for post-render highlighting
            window._deepLinkEdge = edgeName;
          }
        }

        const schemaSaid = params.get('schema');
        if (schemaSaid) {
          // Will be applied after schemas load
          window._deepLinkSchema = schemaSaid;
        }

        const orgId = params.get('org');
        if (orgId) {
          edgeOrgContext = orgId;
          // Prefill recipient AID by looking up org details
          window._deepLinkOrgId = orgId;
        }
      }

      /**
       * Prefill recipient AID from deep-linked org ID.
       * Called after org names are loaded.
       */
      async function applyDeepLinkRecipientPrefill() {
        const orgId = window._deepLinkOrgId;
        if (!orgId) return;
        delete window._deepLinkOrgId;

        // Find org AID from the recipient picker options (populated by loadRecipientOrgs)
        for (const opt of recipientOrgPicker.options) {
          if (opt.dataset.orgId === orgId && opt.value) {
            recipientOrgPicker.value = opt.value;
            recipientInput.value = opt.value;
            return;
          }
        }
      }

      /**
       * Highlight a deep-linked edge slot (expand it and scroll into view).
       * Called after edge slots are rendered.
       */
      function applyDeepLinkEdgeHighlight() {
        const edgeName = window._deepLinkEdge;
        if (!edgeName) return;
        delete window._deepLinkEdge;

        const slotEl = document.querySelector(`.schema-edge-slot[data-edge="${edgeName}"]`);
        if (slotEl) {
          slotEl.classList.add('expanded', 'deep-link-highlight');
          slotEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Remove highlight animation after 3s
          setTimeout(() => slotEl.classList.remove('deep-link-highlight'), 3000);
        }
      }

      // Schema selection triggers form generation + edge parsing
      schemaSelect.addEventListener('change', async () => {
        const said = schemaSelect.value;
        if (!said) {
          dynamicFormContainer.innerHTML = '<p class="hint">Select a schema to see the form fields</p>';
          currentSchemaDoc = null;
          schemaEdgesContainer.style.display = 'none';
          schemaEdgeSlotsContainer.innerHTML = '';
          // Update type card active state
          credentialTypeCardsContainer.querySelectorAll('.cred-type-card').forEach(c => c.classList.remove('active'));
          return;
        }
        await SchemaFormGenerator.generateFromSchema(said, dynamicFormContainer);

        // Parse and render edge slots from schema (Sprint 65)
        if (currentSchemaDoc) {
          const edgeSlots = SchemaEdgeParser.parseEdges(currentSchemaDoc);
          renderSchemaEdgeSlots(edgeSlots);
          // Apply deep-link edge highlighting after slots render
          applyDeepLinkEdgeHighlight();
        }

        // Update type card active state
        credentialTypeCardsContainer.querySelectorAll('.cred-type-card').forEach(card => {
          card.classList.toggle('active', card.dataset.said === said);
        });
      });

      // Load registries
      async function loadRegistries() {
        try {
          const res = await authFetch('/registry');
          if (!res.ok) {
            registrySelect.innerHTML = '<option value="">Unable to load registries</option>';
            return;
          }
          const data = await res.json();

          registrySelect.innerHTML = '<option value="">Select a registry...</option>';
          if (data.count === 0) {
            registrySelect.innerHTML = '<option value="">No registries - create one first</option>';
            return;
          }
          for (const reg of data.registries) {
            const option = document.createElement('option');
            option.value = reg.name;
            option.textContent = `${reg.name} (${reg.registry_key.substring(0, 12)}...)`;
            registrySelect.appendChild(option);
          }
        } catch (e) {
          registrySelect.innerHTML = '<option value="">Unable to load registries</option>';
          console.error(e);
        }
      }

      // Load schemas
      async function loadSchemas() {
        try {
          const res = await authFetch('/schema');
          if (!res.ok) {
            schemaSelect.innerHTML = '<option value="">Unable to load schemas</option>';
            return;
          }
          const data = await res.json();

          schemaSelect.innerHTML = '<option value="">Select a schema...</option>';
          if (data.count === 0) {
            schemaSelect.innerHTML = '<option value="">No schemas available</option>';
            return;
          }
          for (const schema of data.schemas) {
            const option = document.createElement('option');
            option.value = schema.said;
            option.textContent = schema.title;
            schemaSelect.appendChild(option);
            // Build label map (Sprint 65)
            schemaLabelMap.set(schema.said, schema.title);
          }

          // Render credential type cards (Sprint 65)
          renderCredentialTypeCards(data.schemas);

          // Handle deep link schema pre-selection
          if (window._deepLinkSchema) {
            schemaSelect.value = window._deepLinkSchema;
            schemaSelect.dispatchEvent(new Event('change'));
            delete window._deepLinkSchema;
          }
        } catch (e) {
          schemaSelect.innerHTML = '<option value="">Unable to load schemas</option>';
          console.error(e);
        }
      }

      /**
       * Render a table of credentials into a container element.
       * @param {Array} credentials - Enriched credential objects
       * @param {HTMLElement} container - Target DOM element
       * @param {Map} leiInfo - GLEIF LEI lookup results
       * @param {boolean} showOrgColumns - Show Issuer/Recipient org name columns
       */
      function renderCredentialTable(credentials, container, leiInfo, showOrgColumns) {
        if (!credentials || credentials.length === 0) {
          container.innerHTML = '<p class="hint">No credentials.</p>';
          return;
        }

        let html = '<table><thead><tr><th>SAID</th>';
        if (showOrgColumns) {
          html += '<th>Issuer</th><th>Recipient</th>';
        }
        html += '<th>Subject</th><th>Schema</th><th>Status</th><th>Issued</th><th>Actions</th>';
        html += '</tr></thead><tbody>';

        for (const cred of credentials) {
          const statusClass = cred.status === 'issued' ? 'status-issued' : 'status-revoked';
          const issuedDate = cred.issuance_dt ? new Date(cred.issuance_dt).toLocaleDateString() : 'N/A';
          const subjectHtml = buildSubjectDisplay(cred.attributes, leiInfo);

          html += '<tr>';
          html += `<td class="said-cell" title="${cred.said}">${cred.said.substring(0, 16)}...</td>`;

          if (showOrgColumns) {
            const issuerDisplay = cred.issuer_name || (cred.issuer_aid ? cred.issuer_aid.substring(0, 12) + '...' : '-');
            const recipientDisplay = cred.recipient_name || (cred.recipient_aid ? cred.recipient_aid.substring(0, 12) + '...' : '-');
            html += `<td title="${cred.issuer_aid || ''}">${escapeHtml(issuerDisplay)}</td>`;
            html += `<td title="${cred.recipient_aid || ''}">${escapeHtml(recipientDisplay)}</td>`;
          }

          html += `<td class="subject-cell">${subjectHtml}</td>`;
          html += `<td class="said-cell" title="${cred.schema_said}">${cred.schema_said.substring(0, 12)}...</td>`;
          html += `<td><span class="status-badge ${statusClass}">${cred.status}</span></td>`;
          html += `<td>${issuedDate}</td>`;
          html += `<td>${cred.status === 'issued' && cred.relationship !== 'subject' ? `<button class="small danger" onclick="revokeCredential('${cred.said}')">Revoke</button>` : ''}</td>`;
          html += '</tr>';
        }

        html += '</tbody></table>';
        container.innerHTML = html;
      }

      // Load credentials with GLEIF LEI lookup
      async function loadCredentials() {
        try {
          const res = await authFetch('/credential');
          if (!res.ok) {
            issuedCredentialsList.innerHTML = '<p class="hint">Unable to load credentials.</p>';
            return;
          }
          const data = await res.json();

          // Store credentials for edge picker
          availableCredentials = data.credentials || [];

          // Populate datalist for edge target autocomplete
          const datalist = document.getElementById('credentialSaidList');
          datalist.innerHTML = availableCredentials.map(c =>
            `<option value="${c.said}">${c.said.substring(0, 16)}... (${c.schema_said.substring(0, 8)}...)</option>`
          ).join('');

          if (!data.credentials || data.credentials.length === 0) {
            issuedCredentialsList.innerHTML = '<p class="hint">No credentials issued yet. Use the form above to issue your first credential.</p>';
            document.getElementById('subjectCredentialsCard').style.display = 'none';
            document.getElementById('allCredentialsCard').style.display = 'none';
            return;
          }

          // Fetch details for each credential to get attributes (including lids)
          const credentialsWithDetails = await Promise.all(
            data.credentials.map(async (cred) => {
              try {
                const detailRes = await authFetch(`/credential/${cred.said}`);
                if (detailRes.ok) {
                  const detail = await detailRes.json();
                  return { ...cred, attributes: detail.attributes };
                }
              } catch (e) {
                console.warn(`Failed to fetch details for ${cred.said}:`, e);
              }
              return cred;
            })
          );

          // Collect all LEIs from credentials for batch lookup
          const allLeis = [];
          for (const cred of credentialsWithDetails) {
            const lids = cred.attributes?.lids || cred.attributes?.LEI;
            if (Array.isArray(lids)) {
              allLeis.push(...lids);
            } else if (typeof lids === 'string') {
              allLeis.push(lids);
            }
          }

          // Batch lookup all LEIs from GLEIF
          const leiInfo = await GleifService.lookupMany(allLeis);

          // Split into views based on user role
          const admin = isSystemAdmin();

          if (admin) {
            // Admin: single table with org name columns
            document.getElementById('issuedCredentialsCard').style.display = 'none';
            document.getElementById('subjectCredentialsCard').style.display = 'none';
            document.getElementById('allCredentialsCard').style.display = '';
            renderCredentialTable(credentialsWithDetails, allCredentialsList, leiInfo, true);
          } else {
            // Org user: split by relationship
            document.getElementById('allCredentialsCard').style.display = 'none';
            document.getElementById('issuedCredentialsCard').style.display = '';
            document.getElementById('subjectCredentialsCard').style.display = '';

            const issued = credentialsWithDetails.filter(c => c.relationship === 'issued');
            const subject = credentialsWithDetails.filter(c => c.relationship === 'subject');

            renderCredentialTable(issued, issuedCredentialsList, leiInfo, false);
            renderCredentialTable(subject, subjectCredentialsList, leiInfo, false);
          }
        } catch (e) {
          issuedCredentialsList.innerHTML = '<p class="hint">Unable to load credentials.</p>';
          console.error(e);
        }
      }

      /**
       * Build subject display from credential attributes.
       * Prioritizes GLEIF-resolved company names, then legalName, then LEI codes.
       */
      function buildSubjectDisplay(attributes, leiInfo) {
        if (!attributes) return '<span class="hint">-</span>';

        const parts = [];

        // Check for lids (array of LEIs) or LEI (single)
        const lids = attributes.lids || (attributes.LEI ? [attributes.LEI] : []);
        if (lids.length > 0) {
          for (const lei of lids) {
            const info = leiInfo.get(lei);
            if (info?.legalName) {
              parts.push(`
                <div class="lei-subject">
                  <strong>${escapeHtml(info.legalName)}</strong>
                  <span class="gleif-badge" title="Verified via GLEIF">GLEIF</span>
                  <br><a href="https://search.gleif.org/#/record/${lei}" target="_blank" class="lei-link" title="View on GLEIF">${lei}</a>
                </div>
              `);
            } else {
              // LEI not found in GLEIF - show just the code
              parts.push(`
                <div class="lei-subject">
                  <a href="https://search.gleif.org/#/record/${lei}" target="_blank" class="lei-link" title="View on GLEIF">${lei}</a>
                </div>
              `);
            }
          }
        }

        // Check for legalName attribute directly
        if (attributes.legalName && parts.length === 0) {
          parts.push(`<strong>${escapeHtml(attributes.legalName)}</strong>`);
        }

        // Check for telephone numbers (TN credentials)
        if (attributes.numbers?.tn) {
          const tns = Array.isArray(attributes.numbers.tn) ? attributes.numbers.tn : [attributes.numbers.tn];
          parts.push(`<span class="tn-subject">${tns.map(escapeHtml).join(', ')}</span>`);
        }

        // Check for channel
        if (attributes.channel) {
          parts.push(`<span class="channel-badge">${escapeHtml(attributes.channel)}</span>`);
        }

        return parts.length > 0 ? parts.join('') : '<span class="hint">-</span>';
      }

      function escapeHtml(str) {
        if (!str) return '';
        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;');
      }

      /**
       * Sanitize edge name for safe use in element IDs and JS string interpolation.
       * ACDC edge names are alphanumeric identifiers; strip anything else.
       */
      function sanitizeEdgeName(name) {
        return String(name).replace(/[^a-zA-Z0-9_-]/g, '');
      }

      // Issue credential
      issueForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        issueBtn.disabled = true;
        issueBtn.textContent = 'Issuing...';
        issueResult.innerHTML = '';

        try {
          // Get attributes based on current mode
          let attributes;
          if (currentMode === 'form') {
            attributes = FormDataCollector.collect(dynamicFormContainer);
            if (Object.keys(attributes).length === 0) {
              throw new Error('Please fill in the form fields');
            }
          } else {
            // JSON mode - parse textarea
            try {
              attributes = JSON.parse(attributesInput.value);
            } catch (err) {
              throw new Error('Invalid JSON in attributes: ' + err.message);
            }
          }

          const payload = {
            registry_name: registrySelect.value,
            schema_said: schemaSelect.value,
            attributes: attributes,
            private: privateCheck.checked,
            publish_to_witnesses: publishCheck.checked,
          };

          if (recipientInput.value.trim()) {
            payload.recipient_aid = recipientInput.value.trim();
          }

          // Collect edges if any
          const edges = collectEdges();
          if (edges) {
            payload.edges = edges;
          }

          const res = await authFetch('/credential/issue', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify(payload),
          });

          const data = await res.json();

          if (!res.ok) {
            throw new Error(data.detail || 'Failed to issue credential');
          }

          issueResult.innerHTML = `
            <div class="success">
              <strong>Credential Issued Successfully!</strong>
              <div class="result-field">
                <strong>Credential SAID:</strong>
                <code>${data.credential.said}</code>
              </div>
              <div class="result-field">
                <strong>Status:</strong>
                <code>${data.credential.status}</code>
              </div>
              <div class="result-field">
                <strong>Issued At:</strong>
                <code>${data.credential.issuance_dt}</code>
              </div>
            </div>
          `;

          // Refresh the list
          loadCredentials();

          // Clear form
          attributesInput.value = '';
          recipientInput.value = '';
          recipientOrgPicker.value = '';
          privateCheck.checked = false;
          edgesList.innerHTML = ''; // Clear manual edges
          schemaEdgeSelections.clear(); // Clear schema edges

          // Reset dynamic form if in form mode
          if (currentMode === 'form' && schemaSelect.value) {
            SchemaFormGenerator.generateFromSchema(schemaSelect.value, dynamicFormContainer);
          }

        } catch (err) {
          issueResult.innerHTML = `<div class="error"><strong>Error:</strong> ${err.message}</div>`;
        } finally {
          issueBtn.disabled = false;
          issueBtn.textContent = 'Issue Credential';
        }
      });

      // Revoke credential
      async function revokeCredential(said) {
        if (!confirm(`Are you sure you want to revoke credential ${said.substring(0, 16)}...?`)) {
          return;
        }

        try {
          const res = await authFetch(`/credential/${said}/revoke`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({ publish_to_witnesses: true }),
          });

          if (!res.ok) {
            const data = await res.json();
            throw new Error(data.detail || 'Failed to revoke credential');
          }

          alert('Credential revoked successfully');
          loadCredentials();
        } catch (err) {
          alert('Error: ' + err.message);
        }
      }

      // Load recipient org picker (Sprint 65)
      async function loadRecipientOrgs() {
        try {
          const res = await authFetch('/organizations/names');
          if (!res.ok) return;
          const data = await res.json();
          for (const org of (data.organizations || [])) {
            const option = document.createElement('option');
            option.value = org.aid || '';
            option.textContent = org.name;
            option.dataset.orgId = org.id || '';
            recipientOrgPicker.appendChild(option);
          }
        } catch (e) {
          console.warn('Failed to load org names for recipient picker:', e);
        }
      }

      // Recipient org picker fills AID input
      recipientOrgPicker.addEventListener('change', () => {
        if (recipientOrgPicker.value) {
          recipientInput.value = recipientOrgPicker.value;
        }
      });

      // Initialize — await auth status so isSystemAdmin() works in loadCredentials
      (async () => {
        handleDeepLinks();
        await checkAuthStatus();
        updateAuthUI();

        // Set org context from session if not already set by deep link
        if (!edgeOrgContext && currentSession?.organizationId) {
          edgeOrgContext = currentSession.organizationId;
        }

        loadRegistries();
        loadSchemas();
        loadCredentials();
        loadRecipientOrgs().then(() => applyDeepLinkRecipientPrefill());
      })();
    </script>
  </body>
</html>
