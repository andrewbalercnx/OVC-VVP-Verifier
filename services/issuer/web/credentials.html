<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VVP Issuer - Credentials</title>
    <link rel="stylesheet" href="/static/styles.css">
    <style>
      /* Page-specific styles for dynamic form */
      button.danger { background: #e74c3c; }
      button.danger:hover { background: #c0392b; }
      .hint { font-size: 0.875rem; color: #666; margin-top: 0.25rem; }

      /* Dynamic form fields */
      .dynamic-form .form-group { margin-bottom: 1rem; }
      .dynamic-form label { display: block; margin-bottom: 0.25rem; font-weight: 500; font-size: 0.9rem; }
      .dynamic-form .field-hint { font-size: 0.8rem; color: #888; margin-top: 0.15rem; }
      .dynamic-form input[type="text"],
      .dynamic-form input[type="number"],
      .dynamic-form input[type="datetime-local"],
      .dynamic-form select {
        width: 100%;
        padding: 0.6rem;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.95rem;
        box-sizing: border-box;
      }
      .dynamic-form input:focus, .dynamic-form select:focus {
        outline: none;
        border-color: var(--vvp-primary);
        box-shadow: 0 0 0 2px rgba(52,152,219,0.2);
      }
      .dynamic-form .checkbox-field { display: flex; align-items: center; gap: 0.5rem; }
      .dynamic-form .checkbox-field input { width: auto; }
      .dynamic-form .checkbox-field label { margin: 0; font-weight: normal; }

      /* Array fields */
      .array-field {
        border: 1px solid #e9ecef;
        border-radius: 4px;
        padding: 1rem;
        background: #fafafa;
        margin-top: 0.25rem;
      }

      /* Edges styles (Sprint 40) */
      .edges-list { margin-bottom: 0.5rem; }
      .edge-item {
        display: grid;
        grid-template-columns: 150px 1fr auto;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
        padding: 0.5rem;
        background: #f8f9fa;
        border-radius: 4px;
        align-items: center;
      }
      .edge-item select, .edge-item input {
        padding: 0.4rem;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.9rem;
      }
      .edge-item .remove-edge {
        background: #e74c3c;
        color: white;
        border: none;
        padding: 0.4rem 0.6rem;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.8rem;
      }
      .edge-item .remove-edge:hover { background: #c0392b; }
      .hint-inline { font-weight: normal; font-size: 0.85rem; color: #666; }
      .btn-small { padding: 0.4rem 0.8rem; font-size: 0.85rem; }
      .btn-secondary { background: #6c757d; }
      .btn-secondary:hover { background: #5a6268; }
      .array-item { display: flex; gap: 0.5rem; margin-bottom: 0.5rem; align-items: center; }
      .array-item input { flex: 1; }
      .array-item button { padding: 0.4rem 0.6rem; font-size: 0.8rem; background: #e74c3c; }
      .array-item button:hover { background: #c0392b; }
      .add-array-item { background: #27ae60; padding: 0.4rem 0.8rem; font-size: 0.85rem; margin-top: 0.5rem; }
      .add-array-item:hover { background: #219a52; }

      /* Nested objects */
      .nested-object {
        border: 1px solid var(--vvp-border);
        border-radius: 4px;
        padding: 1rem;
        margin-top: 0.5rem;
        background: #fcfcfc;
      }
      .nested-object-title {
        font-weight: 500;
        margin-bottom: 0.75rem;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid #eee;
        color: var(--vvp-text);
      }
      .required-indicator { color: #e74c3c; margin-left: 2px; }

      /* GLEIF LEI display styles */
      .subject-cell { max-width: 280px; }
      .lei-subject {
        display: flex;
        flex-direction: column;
        gap: 0.15rem;
      }
      .lei-subject strong {
        color: var(--vvp-text, #2c3e50);
        font-size: 0.9rem;
      }
      .gleif-badge {
        display: inline-block;
        font-size: 0.65rem;
        font-weight: 600;
        padding: 0.1rem 0.35rem;
        background: #27ae60;
        color: white;
        border-radius: 3px;
        margin-left: 0.35rem;
        vertical-align: middle;
      }
      .lei-link {
        font-size: 0.75rem;
        color: #3498db;
        text-decoration: none;
        font-family: monospace;
      }
      .lei-link:hover { text-decoration: underline; }
      .tn-subject {
        font-family: monospace;
        font-size: 0.85rem;
        color: var(--vvp-text, #2c3e50);
      }
      .channel-badge {
        display: inline-block;
        font-size: 0.7rem;
        padding: 0.1rem 0.4rem;
        background: #3498db;
        color: white;
        border-radius: 3px;
        margin-left: 0.35rem;
        text-transform: uppercase;
      }
    </style>
  </head>
  <body>
    <header class="site-header">
      <div class="header-brand">
        <img src="/static/ovc-logo.png" alt="OVC" class="ovc-logo">
        <a href="/ui/" class="logo">
          <span class="service-label">VVP</span>
          Issuer
        </a>
      </div>
      <nav class="nav-links">
        <a href="/ui/identity">Identities</a>
        <a href="/ui/registry">Registries</a>
        <a href="/ui/schemas">Schemas</a>
        <a href="/ui/credentials" class="active">Credentials</a>
        <a href="/ui/dossier">Dossiers</a>
        <a href="/ui/vvp">VVP Headers</a>
        <a href="/ui/help">Help</a>
        <a href="/ui/admin">Admin</a>
        <a href="/organizations/ui" style="display:none">Organizations</a>
        <a href="https://vvp-verifier.rcnx.io" class="verifier-link" target="_blank">Verifier ↗</a>
      </nav>
    </header>

    <h1>Credential Management</h1>
    <p class="subtitle">Issue and manage ACDC credentials</p>

    <!-- Issue Credential Form -->
    <div class="card">
      <h2>Issue Credential</h2>
      <form id="issueForm">
        <div class="form-group">
          <label for="registry">Registry</label>
          <select id="registry" required>
            <option value="">Loading registries...</option>
          </select>
        </div>

        <div class="form-group">
          <label for="schema">Schema</label>
          <select id="schema" required>
            <option value="">Loading schemas...</option>
          </select>
        </div>

        <div class="form-group">
          <label>Attributes</label>
          <div class="tabs" id="inputModeTabs">
            <button type="button" class="tab active" data-mode="form">Form Mode</button>
            <button type="button" class="tab" data-mode="json">Advanced (JSON)</button>
          </div>
          <div id="formModePanel" class="tab-panel active">
            <div id="dynamicFormContainer" class="dynamic-form">
              <p class="hint">Select a schema to see the form fields</p>
            </div>
          </div>
          <div id="jsonModePanel" class="tab-panel">
            <textarea id="attributes" placeholder='{"numbers": {"tn": ["+12025551234"]}, "channel": "voice", "doNotOriginate": false}'></textarea>
            <p class="hint">Enter the credential attributes as valid JSON. The structure depends on the selected schema.</p>
          </div>
        </div>

        <div class="form-group">
          <label for="recipient">Recipient AID (optional)</label>
          <input type="text" id="recipient" placeholder="Leave empty for untargeted credential"/>
        </div>

        <!-- Edges Section (Sprint 40) -->
        <div class="form-group">
          <label>Edges (optional) <span class="hint-inline">Link to other credentials</span></label>
          <div id="edgesContainer">
            <div class="edges-list" id="edgesList"></div>
            <button type="button" class="btn-secondary btn-small" id="addEdgeBtn">+ Add Edge</button>
          </div>
          <p class="hint">
            Common edges: <code>vetting</code> (APE→LE), <code>delegation</code> (DE→APE/DE),
            <code>jl</code> (TN→LE), <code>certification</code> (constrained creds→Vetter Cert)
          </p>
        </div>

        <div class="checkbox-row">
          <input type="checkbox" id="private"/>
          <label for="private">Add privacy-preserving nonces</label>
        </div>

        <div class="checkbox-row">
          <input type="checkbox" id="publishWitnesses" checked/>
          <label for="publishWitnesses">Publish to witnesses</label>
        </div>

        <button type="submit" id="issueBtn">Issue Credential</button>
      </form>

      <div id="issueResult"></div>
    </div>

    <!-- Credentials List -->
    <div class="card">
      <h2>Issued Credentials</h2>
      <div id="credentialsList">
        <p class="loading">Loading credentials...</p>
      </div>
    </div>

    <!-- Datalist for credential SAIDs (for edge picker) -->
    <datalist id="credentialSaidList"></datalist>

    <script>
      const registrySelect = document.getElementById('registry');
      const schemaSelect = document.getElementById('schema');
      const attributesInput = document.getElementById('attributes');
      const recipientInput = document.getElementById('recipient');
      const privateCheck = document.getElementById('private');
      const publishCheck = document.getElementById('publishWitnesses');
      const issueForm = document.getElementById('issueForm');
      const issueBtn = document.getElementById('issueBtn');
      const issueResult = document.getElementById('issueResult');
      const credentialsList = document.getElementById('credentialsList');
      const dynamicFormContainer = document.getElementById('dynamicFormContainer');
      const formModePanel = document.getElementById('formModePanel');
      const jsonModePanel = document.getElementById('jsonModePanel');
      const modeTabs = document.querySelectorAll('#inputModeTabs .tab');
      const edgesList = document.getElementById('edgesList');
      const addEdgeBtn = document.getElementById('addEdgeBtn');

      // Track current input mode
      let currentMode = 'form';
      let currentSchemaDoc = null;
      let availableCredentials = [];

      // =====================================================================
      // GLEIF LEI Lookup Service
      // =====================================================================
      const GleifService = {
        cache: new Map(),
        pendingRequests: new Map(),

        /**
         * Look up a Legal Entity Identifier (LEI) via the GLEIF API.
         * @param {string} lei - The 20-character LEI
         * @returns {Promise<{legalName: string, country: string, lei: string} | null>}
         */
        async lookup(lei) {
          if (!lei || lei.length !== 20) return null;

          // Check cache first
          if (this.cache.has(lei)) {
            return this.cache.get(lei);
          }

          // Deduplicate concurrent requests for the same LEI
          if (this.pendingRequests.has(lei)) {
            return this.pendingRequests.get(lei);
          }

          const promise = this._fetchLei(lei);
          this.pendingRequests.set(lei, promise);

          try {
            const result = await promise;
            this.cache.set(lei, result);
            return result;
          } finally {
            this.pendingRequests.delete(lei);
          }
        },

        async _fetchLei(lei) {
          try {
            const res = await fetch(`https://api.gleif.org/api/v1/lei-records/${lei}`);
            if (!res.ok) return null;

            const data = await res.json();
            const entity = data.data?.attributes?.entity;
            if (!entity) return null;

            return {
              lei: lei,
              legalName: entity.legalName?.name || null,
              country: entity.legalAddress?.country || null,
              tradingName: entity.otherNames?.find(n => n.type === 'TRADING_OR_OPERATING_NAME')?.name || null,
            };
          } catch (e) {
            console.warn(`GLEIF lookup failed for ${lei}:`, e);
            return null;
          }
        },

        /**
         * Look up multiple LEIs and return results keyed by LEI.
         * @param {string[]} leis - Array of LEI strings
         * @returns {Promise<Map<string, object>>}
         */
        async lookupMany(leis) {
          const results = new Map();
          const uniqueLeis = [...new Set(leis.filter(Boolean))];

          await Promise.all(
            uniqueLeis.map(async (lei) => {
              const info = await this.lookup(lei);
              if (info) results.set(lei, info);
            })
          );

          return results;
        }
      };

      // Common edge types for dropdown
      const EDGE_TYPES = [
        { value: 'certification', label: 'certification (→Vetter Cert)' },
        { value: 'vetting', label: 'vetting (APE→LE)' },
        { value: 'delegation', label: 'delegation (DE→APE/DE)' },
        { value: 'jl', label: 'jl (TN→LE)' },
        { value: 'le', label: 'le (→Legal Entity)' },
        { value: 'custom', label: 'custom...' },
      ];

      // Edge management functions
      function createEdgeRow() {
        const row = document.createElement('div');
        row.className = 'edge-item';

        // Edge type selector
        const typeSelect = document.createElement('select');
        typeSelect.className = 'edge-type';
        typeSelect.innerHTML = EDGE_TYPES.map(t =>
          `<option value="${t.value}">${t.label}</option>`
        ).join('');

        // Custom type input (hidden by default)
        const customInput = document.createElement('input');
        customInput.type = 'text';
        customInput.className = 'edge-custom-type';
        customInput.placeholder = 'Edge name';
        customInput.style.display = 'none';

        typeSelect.addEventListener('change', () => {
          customInput.style.display = typeSelect.value === 'custom' ? 'block' : 'none';
        });

        // Target SAID input/select
        const targetInput = document.createElement('input');
        targetInput.type = 'text';
        targetInput.className = 'edge-target';
        targetInput.placeholder = 'Target credential SAID';
        targetInput.list = 'credentialSaidList';

        // Remove button
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'remove-edge';
        removeBtn.textContent = '✕';
        removeBtn.onclick = () => row.remove();

        row.appendChild(typeSelect);
        row.appendChild(customInput);
        row.appendChild(targetInput);
        row.appendChild(removeBtn);

        return row;
      }

      function collectEdges() {
        const edges = {};
        const rows = edgesList.querySelectorAll('.edge-item');

        rows.forEach(row => {
          const typeSelect = row.querySelector('.edge-type');
          const customInput = row.querySelector('.edge-custom-type');
          const targetInput = row.querySelector('.edge-target');

          const edgeType = typeSelect.value === 'custom' ? customInput.value : typeSelect.value;
          const targetSaid = targetInput.value.trim();

          if (edgeType && targetSaid) {
            // Look up schema SAID for the target credential
            const targetCred = availableCredentials.find(c => c.said === targetSaid);
            edges[edgeType] = {
              n: targetSaid,
              s: targetCred?.schema_said || ''
            };
          }
        });

        return Object.keys(edges).length > 0 ? edges : null;
      }

      // Add edge button handler
      addEdgeBtn.addEventListener('click', () => {
        edgesList.appendChild(createEdgeRow());
      });

      // System fields to skip (auto-populated by backend)
      const SYSTEM_FIELDS = ['d', 'u', 'i', 'dt'];

      // Tab switching
      modeTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const mode = tab.dataset.mode;
          if (mode === currentMode) return;

          // Sync data before switching
          if (currentMode === 'form' && mode === 'json') {
            // Form -> JSON: collect form data to textarea
            const formData = FormDataCollector.collect(dynamicFormContainer);
            if (Object.keys(formData).length > 0) {
              attributesInput.value = JSON.stringify(formData, null, 2);
            }
          }

          // Update tab styling
          modeTabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');

          // Show/hide panels
          formModePanel.classList.toggle('active', mode === 'form');
          jsonModePanel.classList.toggle('active', mode === 'json');
          currentMode = mode;
        });
      });

      // Schema Form Generator
      class SchemaFormGenerator {
        static async generateFromSchema(said, container) {
          container.innerHTML = '<p class="hint">Loading schema...</p>';

          try {
            const res = await fetch(`/schema/${said}`);
            if (!res.ok) throw new Error('Failed to load schema');
            const schema = await res.json();

            currentSchemaDoc = schema.schema_document;
            if (!currentSchemaDoc) {
              container.innerHTML = '<p class="hint">Schema has no document - use JSON mode</p>';
              return;
            }

            // Extract attributes schema from properties.a.oneOf[1] (the object variant)
            const attrSchema = this.extractAttributesSchema(currentSchemaDoc);
            if (!attrSchema || !attrSchema.properties) {
              container.innerHTML = '<p class="hint">Could not extract attributes schema - use JSON mode</p>';
              return;
            }

            // Generate form fields
            container.innerHTML = '';
            this.renderFields(attrSchema, container, '');

          } catch (e) {
            console.error('Schema generation error:', e);
            container.innerHTML = `<p class="error">Error loading schema: ${e.message}</p>`;
          }
        }

        static extractAttributesSchema(schemaDoc) {
          // Try properties.a.oneOf[1] first (standard ACDC structure)
          if (schemaDoc.properties?.a?.oneOf) {
            const objVariant = schemaDoc.properties.a.oneOf.find(v => v.type === 'object');
            if (objVariant) return objVariant;
          }
          // Fallback: properties.a directly if it's an object schema
          if (schemaDoc.properties?.a?.type === 'object') {
            return schemaDoc.properties.a;
          }
          // Last resort: the schema itself
          return schemaDoc;
        }

        static renderFields(schema, container, pathPrefix) {
          const required = schema.required || [];

          for (const [key, prop] of Object.entries(schema.properties || {})) {
            // Skip system fields
            if (SYSTEM_FIELDS.includes(key)) continue;

            const path = pathPrefix ? `${pathPrefix}.${key}` : key;
            const isRequired = required.includes(key);

            if (prop.type === 'object' && prop.properties) {
              // Nested object
              this.renderNestedObject(key, prop, container, path, isRequired);
            } else if (prop.type === 'array') {
              // Array field
              this.renderArrayField(key, prop, container, path, isRequired);
            } else {
              // Simple field
              this.renderSimpleField(key, prop, container, path, isRequired);
            }
          }
        }

        static renderSimpleField(key, prop, container, path, isRequired) {
          const group = document.createElement('div');
          group.className = 'form-group';

          const label = document.createElement('label');
          label.textContent = prop.title || this.formatLabel(key);
          if (isRequired) {
            const req = document.createElement('span');
            req.className = 'required-indicator';
            req.textContent = '*';
            label.appendChild(req);
          }

          let input;

          // Determine input type based on schema
          if (prop.pattern && (prop.pattern.includes('|'))) {
            // Pattern with alternatives - use select
            input = document.createElement('select');
            const options = prop.pattern.split('|').map(o => o.replace(/[^a-zA-Z0-9]/g, ''));
            const emptyOpt = document.createElement('option');
            emptyOpt.value = '';
            emptyOpt.textContent = `Select ${this.formatLabel(key)}...`;
            input.appendChild(emptyOpt);
            for (const opt of options) {
              const option = document.createElement('option');
              option.value = opt;
              option.textContent = opt;
              input.appendChild(option);
            }
          } else if (prop.format === 'date-time') {
            input = document.createElement('input');
            input.type = 'datetime-local';
          } else if (prop.type === 'boolean') {
            // Checkbox
            group.className = 'form-group checkbox-field';
            input = document.createElement('input');
            input.type = 'checkbox';
            input.id = `field_${path.replace(/\./g, '_')}`;
            label.setAttribute('for', input.id);
          } else if (prop.type === 'integer' || prop.type === 'number') {
            input = document.createElement('input');
            input.type = 'number';
            if (prop.minimum !== undefined) input.min = prop.minimum;
            if (prop.maximum !== undefined) input.max = prop.maximum;
          } else {
            input = document.createElement('input');
            input.type = 'text';
            if (prop.pattern) input.pattern = prop.pattern;
          }

          input.dataset.path = path;
          input.dataset.type = prop.type || 'string';
          if (isRequired && prop.type !== 'boolean') input.required = true;
          if (prop.default !== undefined && prop.type !== 'boolean') input.value = prop.default;
          if (prop.type === 'boolean' && prop.default === true) input.checked = true;

          if (prop.type === 'boolean') {
            group.appendChild(input);
            group.appendChild(label);
          } else {
            group.appendChild(label);
            group.appendChild(input);
          }

          // Add description hint
          if (prop.description) {
            const hint = document.createElement('p');
            hint.className = 'field-hint';
            hint.textContent = prop.description;
            group.appendChild(hint);
          }

          container.appendChild(group);
        }

        static renderArrayField(key, prop, container, path, isRequired) {
          const group = document.createElement('div');
          group.className = 'form-group';

          const label = document.createElement('label');
          label.textContent = prop.title || this.formatLabel(key);
          if (isRequired) {
            const req = document.createElement('span');
            req.className = 'required-indicator';
            req.textContent = '*';
            label.appendChild(req);
          }
          group.appendChild(label);

          const arrayContainer = document.createElement('div');
          arrayContainer.className = 'array-field';
          arrayContainer.dataset.path = path;
          arrayContainer.dataset.type = 'array';

          const itemsContainer = document.createElement('div');
          itemsContainer.className = 'array-items';

          // Add initial item
          this.addArrayItem(itemsContainer, prop.items || {}, path);

          arrayContainer.appendChild(itemsContainer);

          // Add button
          const addBtn = document.createElement('button');
          addBtn.type = 'button';
          addBtn.className = 'add-array-item';
          addBtn.textContent = '+ Add';
          addBtn.onclick = () => this.addArrayItem(itemsContainer, prop.items || {}, path);
          arrayContainer.appendChild(addBtn);

          group.appendChild(arrayContainer);
          container.appendChild(group);
        }

        static addArrayItem(container, itemSchema, basePath) {
          const idx = container.children.length;
          const itemDiv = document.createElement('div');
          itemDiv.className = 'array-item';

          const input = document.createElement('input');
          input.type = 'text';
          input.dataset.path = `${basePath}[${idx}]`;
          input.dataset.type = itemSchema.type || 'string';
          if (itemSchema.pattern) input.pattern = itemSchema.pattern;
          if (itemSchema.format === 'phone') input.placeholder = '+12025551234';

          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.textContent = '×';
          removeBtn.onclick = () => {
            itemDiv.remove();
            this.reindexArrayItems(container, basePath);
          };

          itemDiv.appendChild(input);
          itemDiv.appendChild(removeBtn);
          container.appendChild(itemDiv);
        }

        static reindexArrayItems(container, basePath) {
          const items = container.querySelectorAll('.array-item input');
          items.forEach((input, idx) => {
            input.dataset.path = `${basePath}[${idx}]`;
          });
        }

        static renderNestedObject(key, prop, container, path, isRequired) {
          const group = document.createElement('div');
          group.className = 'form-group';

          const nested = document.createElement('div');
          nested.className = 'nested-object';

          const title = document.createElement('div');
          title.className = 'nested-object-title';
          title.textContent = prop.title || this.formatLabel(key);
          if (isRequired) {
            const req = document.createElement('span');
            req.className = 'required-indicator';
            req.textContent = ' *';
            title.appendChild(req);
          }
          nested.appendChild(title);

          // Render nested fields
          this.renderFields(prop, nested, path);

          group.appendChild(nested);
          container.appendChild(group);
        }

        static formatLabel(key) {
          // Convert camelCase to Title Case
          return key
            .replace(/([A-Z])/g, ' $1')
            .replace(/^./, str => str.toUpperCase())
            .trim();
        }
      }

      // Form Data Collector
      class FormDataCollector {
        static collect(container) {
          const data = {};
          const inputs = container.querySelectorAll('[data-path]');

          inputs.forEach(input => {
            const path = input.dataset.path;
            const type = input.dataset.type;

            let value;
            if (input.type === 'checkbox') {
              value = input.checked;
            } else if (type === 'integer') {
              value = input.value ? parseInt(input.value, 10) : undefined;
            } else if (type === 'number') {
              value = input.value ? parseFloat(input.value) : undefined;
            } else if (type === 'boolean') {
              value = input.checked;
            } else {
              value = input.value || undefined;
            }

            // Skip empty values (except booleans)
            if (value === undefined || value === '') return;

            this.setNestedValue(data, path, value);
          });

          return data;
        }

        static setNestedValue(obj, path, value) {
          // Parse path like "numbers.tn[0]" or "channel"
          const parts = path.match(/[^.\[\]]+|\[\d+\]/g) || [];

          let current = obj;
          for (let i = 0; i < parts.length - 1; i++) {
            let part = parts[i];
            const nextPart = parts[i + 1];

            // Handle array index
            if (part.startsWith('[')) {
              part = parseInt(part.slice(1, -1), 10);
            }

            // Determine if next level is array or object
            const nextIsArray = nextPart && nextPart.startsWith('[');

            if (current[part] === undefined) {
              current[part] = nextIsArray ? [] : {};
            }
            current = current[part];
          }

          // Set the final value
          let finalPart = parts[parts.length - 1];
          if (finalPart.startsWith('[')) {
            finalPart = parseInt(finalPart.slice(1, -1), 10);
          }
          current[finalPart] = value;
        }
      }

      // Schema selection triggers form generation
      schemaSelect.addEventListener('change', async () => {
        const said = schemaSelect.value;
        if (!said) {
          dynamicFormContainer.innerHTML = '<p class="hint">Select a schema to see the form fields</p>';
          currentSchemaDoc = null;
          return;
        }
        await SchemaFormGenerator.generateFromSchema(said, dynamicFormContainer);
      });

      // Load registries
      async function loadRegistries() {
        try {
          const res = await fetch('/registry');
          if (!res.ok) {
            registrySelect.innerHTML = '<option value="">Unable to load registries</option>';
            return;
          }
          const data = await res.json();

          registrySelect.innerHTML = '<option value="">Select a registry...</option>';
          if (data.count === 0) {
            registrySelect.innerHTML = '<option value="">No registries - create one first</option>';
            return;
          }
          for (const reg of data.registries) {
            const option = document.createElement('option');
            option.value = reg.name;
            option.textContent = `${reg.name} (${reg.registry_key.substring(0, 12)}...)`;
            registrySelect.appendChild(option);
          }
        } catch (e) {
          registrySelect.innerHTML = '<option value="">Unable to load registries</option>';
          console.error(e);
        }
      }

      // Load schemas
      async function loadSchemas() {
        try {
          const res = await fetch('/schema');
          if (!res.ok) {
            schemaSelect.innerHTML = '<option value="">Unable to load schemas</option>';
            return;
          }
          const data = await res.json();

          schemaSelect.innerHTML = '<option value="">Select a schema...</option>';
          if (data.count === 0) {
            schemaSelect.innerHTML = '<option value="">No schemas available</option>';
            return;
          }
          for (const schema of data.schemas) {
            const option = document.createElement('option');
            option.value = schema.said;
            option.textContent = schema.title;
            schemaSelect.appendChild(option);
          }
        } catch (e) {
          schemaSelect.innerHTML = '<option value="">Unable to load schemas</option>';
          console.error(e);
        }
      }

      // Load credentials with GLEIF LEI lookup
      async function loadCredentials() {
        try {
          const res = await fetch('/credential');
          if (!res.ok) {
            credentialsList.innerHTML = '<p class="hint">Unable to load credentials.</p>';
            return;
          }
          const data = await res.json();

          // Store credentials for edge picker
          availableCredentials = data.credentials || [];

          // Populate datalist for edge target autocomplete
          const datalist = document.getElementById('credentialSaidList');
          datalist.innerHTML = availableCredentials.map(c =>
            `<option value="${c.said}">${c.said.substring(0, 16)}... (${c.schema_said.substring(0, 8)}...)</option>`
          ).join('');

          if (!data.credentials || data.credentials.length === 0) {
            credentialsList.innerHTML = '<p class="hint">No credentials issued yet. Use the form above to issue your first credential.</p>';
            return;
          }

          // Fetch details for each credential to get attributes (including lids)
          const credentialsWithDetails = await Promise.all(
            data.credentials.map(async (cred) => {
              try {
                const detailRes = await fetch(`/credential/${cred.said}`);
                if (detailRes.ok) {
                  const detail = await detailRes.json();
                  return { ...cred, attributes: detail.attributes };
                }
              } catch (e) {
                console.warn(`Failed to fetch details for ${cred.said}:`, e);
              }
              return cred;
            })
          );

          // Collect all LEIs from credentials for batch lookup
          const allLeis = [];
          for (const cred of credentialsWithDetails) {
            const lids = cred.attributes?.lids || cred.attributes?.LEI;
            if (Array.isArray(lids)) {
              allLeis.push(...lids);
            } else if (typeof lids === 'string') {
              allLeis.push(lids);
            }
          }

          // Batch lookup all LEIs from GLEIF
          const leiInfo = await GleifService.lookupMany(allLeis);

          let html = `
            <table>
              <thead>
                <tr>
                  <th>SAID</th>
                  <th>Subject</th>
                  <th>Schema</th>
                  <th>Status</th>
                  <th>Issued</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody>
          `;

          for (const cred of credentialsWithDetails) {
            const statusClass = cred.status === 'issued' ? 'status-issued' : 'status-revoked';
            const issuedDate = cred.issuance_dt ? new Date(cred.issuance_dt).toLocaleDateString() : 'N/A';

            // Build subject display from attributes
            const subjectHtml = buildSubjectDisplay(cred.attributes, leiInfo);

            html += `
              <tr>
                <td class="said-cell" title="${cred.said}">${cred.said.substring(0, 16)}...</td>
                <td class="subject-cell">${subjectHtml}</td>
                <td class="said-cell" title="${cred.schema_said}">${cred.schema_said.substring(0, 12)}...</td>
                <td><span class="status-badge ${statusClass}">${cred.status}</span></td>
                <td>${issuedDate}</td>
                <td>
                  ${cred.status === 'issued' ? `<button class="small danger" onclick="revokeCredential('${cred.said}')">Revoke</button>` : ''}
                </td>
              </tr>
            `;
          }

          html += '</tbody></table>';
          credentialsList.innerHTML = html;
        } catch (e) {
          credentialsList.innerHTML = '<p class="hint">Unable to load credentials.</p>';
          console.error(e);
        }
      }

      /**
       * Build subject display from credential attributes.
       * Prioritizes GLEIF-resolved company names, then legalName, then LEI codes.
       */
      function buildSubjectDisplay(attributes, leiInfo) {
        if (!attributes) return '<span class="hint">-</span>';

        const parts = [];

        // Check for lids (array of LEIs) or LEI (single)
        const lids = attributes.lids || (attributes.LEI ? [attributes.LEI] : []);
        if (lids.length > 0) {
          for (const lei of lids) {
            const info = leiInfo.get(lei);
            if (info?.legalName) {
              parts.push(`
                <div class="lei-subject">
                  <strong>${escapeHtml(info.legalName)}</strong>
                  <span class="gleif-badge" title="Verified via GLEIF">GLEIF</span>
                  <br><a href="https://search.gleif.org/#/record/${lei}" target="_blank" class="lei-link" title="View on GLEIF">${lei}</a>
                </div>
              `);
            } else {
              // LEI not found in GLEIF - show just the code
              parts.push(`
                <div class="lei-subject">
                  <a href="https://search.gleif.org/#/record/${lei}" target="_blank" class="lei-link" title="View on GLEIF">${lei}</a>
                </div>
              `);
            }
          }
        }

        // Check for legalName attribute directly
        if (attributes.legalName && parts.length === 0) {
          parts.push(`<strong>${escapeHtml(attributes.legalName)}</strong>`);
        }

        // Check for telephone numbers (TN credentials)
        if (attributes.numbers?.tn) {
          const tns = Array.isArray(attributes.numbers.tn) ? attributes.numbers.tn : [attributes.numbers.tn];
          parts.push(`<span class="tn-subject">${tns.map(escapeHtml).join(', ')}</span>`);
        }

        // Check for channel
        if (attributes.channel) {
          parts.push(`<span class="channel-badge">${escapeHtml(attributes.channel)}</span>`);
        }

        return parts.length > 0 ? parts.join('') : '<span class="hint">-</span>';
      }

      function escapeHtml(str) {
        if (!str) return '';
        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;');
      }

      // Issue credential
      issueForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        issueBtn.disabled = true;
        issueBtn.textContent = 'Issuing...';
        issueResult.innerHTML = '';

        try {
          // Get attributes based on current mode
          let attributes;
          if (currentMode === 'form') {
            attributes = FormDataCollector.collect(dynamicFormContainer);
            if (Object.keys(attributes).length === 0) {
              throw new Error('Please fill in the form fields');
            }
          } else {
            // JSON mode - parse textarea
            try {
              attributes = JSON.parse(attributesInput.value);
            } catch (err) {
              throw new Error('Invalid JSON in attributes: ' + err.message);
            }
          }

          const payload = {
            registry_name: registrySelect.value,
            schema_said: schemaSelect.value,
            attributes: attributes,
            private: privateCheck.checked,
            publish_to_witnesses: publishCheck.checked,
          };

          if (recipientInput.value.trim()) {
            payload.recipient_aid = recipientInput.value.trim();
          }

          // Collect edges if any
          const edges = collectEdges();
          if (edges) {
            payload.edges = edges;
          }

          const res = await fetch('/credential/issue', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify(payload),
          });

          const data = await res.json();

          if (!res.ok) {
            throw new Error(data.detail || 'Failed to issue credential');
          }

          issueResult.innerHTML = `
            <div class="success">
              <strong>Credential Issued Successfully!</strong>
              <div class="result-field">
                <strong>Credential SAID:</strong>
                <code>${data.credential.said}</code>
              </div>
              <div class="result-field">
                <strong>Status:</strong>
                <code>${data.credential.status}</code>
              </div>
              <div class="result-field">
                <strong>Issued At:</strong>
                <code>${data.credential.issuance_dt}</code>
              </div>
            </div>
          `;

          // Refresh the list
          loadCredentials();

          // Clear form
          attributesInput.value = '';
          recipientInput.value = '';
          privateCheck.checked = false;
          edgesList.innerHTML = ''; // Clear edges

          // Reset dynamic form if in form mode
          if (currentMode === 'form' && schemaSelect.value) {
            SchemaFormGenerator.generateFromSchema(schemaSelect.value, dynamicFormContainer);
          }

        } catch (err) {
          issueResult.innerHTML = `<div class="error"><strong>Error:</strong> ${err.message}</div>`;
        } finally {
          issueBtn.disabled = false;
          issueBtn.textContent = 'Issue Credential';
        }
      });

      // Revoke credential
      async function revokeCredential(said) {
        if (!confirm(`Are you sure you want to revoke credential ${said.substring(0, 16)}...?`)) {
          return;
        }

        try {
          const res = await fetch(`/credential/${said}/revoke`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({ publish_to_witnesses: true }),
          });

          if (!res.ok) {
            const data = await res.json();
            throw new Error(data.detail || 'Failed to revoke credential');
          }

          alert('Credential revoked successfully');
          loadCredentials();
        } catch (err) {
          alert('Error: ' + err.message);
        }
      }

      // Initialize
      loadRegistries();
      loadSchemas();
      loadCredentials();
    </script>
    <script src="/static/shared.js"></script>
  </body>
</html>
