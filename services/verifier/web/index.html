<!doctype html>
<html>
  <head><meta charset="utf-8"/><title>VVP Verifier</title><link rel="icon" href="/static/favicon.ico" type="image/x-icon"></head>
  <body style="font-family:system-ui; margin:2rem; max-width:900px">
    <h1>VVP Verifier</h1>

    <h2>Parse PASSporT JWT</h2>
    <p>Paste a VVP PASSporT JWT to decode and view its contents.</p>
    <label>PASSporT JWT</label><br/>
    <textarea id="jwt" style="width:100%;height:120px" placeholder="eyJhbGciOiJFZERTQSI...">eyJhbGciOiJFZERTQSIsInR5cCI6InBhc3Nwb3J0IiwicHB0IjoidnZwIiwia2lkIjoiaHR0cDovL3dpdG5lc3M1LnN0YWdlLnByb3ZlbmFudC5uZXQ6NTYzMS9vb2JpL0VHYXk1dWZCcUFhbmJoRmFfcWUtS01GVVBKSG44SjBNRmJhOTZ5eVdSckxGL3dpdG5lc3MifQ.eyJvcmlnIjp7InRuIjpbIjQ0Nzg4NDY2NjIwMCJdfSwiZGVzdCI6eyJ0biI6WyI0NDc3Njk3MTAyODUiXX0sImlhdCI6MTc2OTE4MzMwMiwiY2FyZCI6WyJDQVRFR09SSUVTOiIsIkxPR087SEFTSD1zaGEyNTYtNDBiYWM2ODZhM2YwYjQ4MjUzZGU1NWIzNGY1NTJjODA3MGJhZjIyZjgxMjU1YWFjNDQ5NzIxYzg3OWM3MTZhNDtWQUxVRT1VUkk6aHR0cHM6Ly9vcmlnaW4tY2VsbC1mcmFua2Z1cnQuczMuZXUtY2VudHJhbC0xLmFtYXpvbmF3cy5jb20vYnJhbmQtYXNzZXRzL3JpY2gtY29ubmV4aW9ucy9sb2dvLnBuZyIsIk5PVEU7TEVJOjk4NDUwMERFRTc1MzdBMDdZNjE1IiwiT1JHOlJpY2ggQ29ubmV4aW9ucyJdLCJjYWxsX3JlYXNvbiI6bnVsbCwiZ29hbCI6bnVsbCwiZXZkIjoiaHR0cHM6Ly9vcmlnaW4uZGVtby5wcm92ZW5hbnQubmV0L3YxL2FnZW50L3B1YmxpYy9FSGxWWFVKLWRZS3F0UGR2enRkQ0ZKRWJreXI2elgyZFgxMmh3ZEU5eDhleS9kb3NzaWVyLmNlc3IiLCJvcmlnSWQiOiIiLCJleHAiOjE3NjkxODM2MDIsInJlcXVlc3RfaWQiOiIifQ.OvoaiAwt1dgPb6gLkK7ufWoL2qzdtmudyyiL38oqB0wfaicGSG4B_QFtHY2vS2w-PYZ6LhN9dWXpsOHtpKAXCw</textarea><br/><br/>
    <button id="parseJwtBtn">Parse JWT</button>

    <h2>Parsed PASSporT</h2>
    <div id="parsedOutput" style="background:#f6f6f6;padding:1rem;overflow:auto;white-space:pre-wrap;font-family:monospace;min-height:100px"></div>

    <div id="dossierSection" style="display:none; margin-top:1rem;">
      <h2>Dossier (Evidence)</h2>
      <p>Evidence URL: <code id="evdUrl" style="word-break:break-all;"></code></p>
      <button id="fetchDossierBtn">Fetch Dossier</button>
      <button id="mockDossierBtn" style="margin-left:0.5rem;">Use Mock Dossier</button>
      <button id="checkRevocationBtn" style="margin-left:0.5rem;background:#6c757d;color:white;border:none;padding:5px 10px;cursor:pointer;" disabled>Check Live Revocation</button>
      <div id="dossierOutput" style="background:#f6f6f6;padding:1rem;overflow:auto;white-space:pre-wrap;font-family:monospace;min-height:100px;margin-top:1rem;"></div>
    </div>

    <div id="verifySection" style="display:none; margin-top:1.5rem; padding:1rem; background:#f0f8ff; border:1px solid #0066cc; border-radius:4px;">
      <h3 style="margin-top:0;">Full Verification</h3>
      <p style="font-size:0.9em; color:#555;">Run the complete /verify API flow to test if this attestation would pass in production.</p>
      <button id="runVerifyBtn" style="background:#0066cc;color:white;border:none;padding:8px 16px;cursor:pointer;border-radius:4px;font-size:1em;">Run Full Verification</button>
      <div id="verifyResult" style="margin-top:1rem;"></div>
    </div>

    <hr style="margin:2rem 0"/>

    <details>
      <summary><strong>Parse from SIP INVITE</strong></summary>
      <p style="margin-top:1rem;">Paste a raw SIP INVITE message to extract the Identity header.</p>
      <label>Raw SIP INVITE</label><br/>
      <textarea id="sipInvite" style="width:100%;height:200px" placeholder="INVITE sip:..."></textarea><br/><br/>
      <button id="parseSipBtn">Parse SIP INVITE</button>
    </details>

    <script>
      // Store current evd URL and fetched ACDCs
      let currentEvdUrl = null;
      let currentAcdcs = [];
      let currentOobiUrl = null;
      let currentKidUrl = null;  // kid field from JWT header - witness OOBI URL
      let currentDossierStream = null;  // Raw CESR dossier for inline TEL parsing
      let currentPassportJwt = null;  // Full JWT string for verification
      let currentParsedPayload = null;  // Parsed JWT payload for iat extraction

      // Base64url decode helper
      function base64urlDecode(str) {
        let padded = str.replace(/-/g, '+').replace(/_/g, '/');
        while (padded.length % 4) padded += '=';
        return atob(padded);
      }

      // Parse and display a JWT
      function parseAndDisplayJwt(jwt) {
        const output = document.getElementById("parsedOutput");

        try {
          // Strip ;ppt=vvp suffix if present
          if (jwt.includes(';')) {
            jwt = jwt.split(';')[0];
          }
          jwt = jwt.trim();

          // Split JWT into parts
          const parts = jwt.split('.');
          if (parts.length !== 3) {
            output.textContent = "Error: Invalid JWT format (expected 3 parts, got " + parts.length + ")";
            document.getElementById("dossierSection").style.display = "none";
            return false;
          }

          // Decode header and payload
          const header = JSON.parse(base64urlDecode(parts[0]));
          const payload = JSON.parse(base64urlDecode(parts[1]));

          // Store JWT and payload for verification
          currentPassportJwt = jwt;
          currentParsedPayload = payload;

          // Format output
          const result = {
            header: header,
            payload: payload,
            signature: parts[2] + " (base64url-encoded, " + parts[2].length + " chars)"
          };

          output.textContent = JSON.stringify(result, null, 2);

          // Store kid from header - this is the witness OOBI URL for TEL queries
          // Per KERI/Provenant: kid format is like http://witness5.stage.provenant.net:5631/oobi/{AID}/witness
          if (header.kid) {
            currentKidUrl = header.kid;
            console.log("Extracted kid (witness OOBI):", currentKidUrl);
          }

          // Show dossier section if evd URL exists
          if (payload.evd) {
            currentEvdUrl = payload.evd;
            document.getElementById("evdUrl").textContent = currentEvdUrl;
            document.getElementById("dossierSection").style.display = "block";
            document.getElementById("dossierOutput").innerHTML = "<em>Click 'Fetch Dossier' to retrieve claims</em>";
          } else {
            document.getElementById("dossierSection").style.display = "none";
          }

          // Reset verify section (will show after dossier is fetched)
          document.getElementById("verifySection").style.display = "none";
          document.getElementById("verifyResult").innerHTML = "";

          return true;

        } catch (e) {
          output.textContent = "Error parsing: " + e.message;
          document.getElementById("dossierSection").style.display = "none";
          return false;
        }
      }

      // Find issuer details from dossier ACDCs
      // Looks for organization name, LEI, and other identity attributes
      function findIssuerDetails(issuerAid, allAcdcs) {
        const details = {
          aid: issuerAid,
          name: null,
          lei: null,
          role: null,
          credentials: []  // ACDCs where this AID appears as issuer
        };

        if (!issuerAid || !allAcdcs || allAcdcs.length === 0) {
          return details;
        }

        for (const acdc of allAcdcs) {
          // Check if this ACDC has attributes about the issuer
          // This could be an identity credential where the issuer is the subject
          const attrs = acdc.a;
          if (!attrs || typeof attrs !== 'object') continue;

          // Check if this ACDC's issuee (subject) matches the issuer AID
          // The 'i' field in attributes often indicates the subject AID
          const subjectAid = attrs.i || attrs.issuee;

          if (subjectAid === issuerAid || acdc.i === issuerAid) {
            // Extract organization name from vCard
            if (attrs.vcard && Array.isArray(attrs.vcard)) {
              for (const line of attrs.vcard) {
                if (line.startsWith('ORG:') && !details.name) {
                  details.name = line.substring(4);
                }
                if (line.includes('LEI:') && !details.lei) {
                  const lei = line.match(/LEI:([A-Z0-9]+)/);
                  if (lei) details.lei = lei[1];
                }
              }
            }

            // Extract from direct attributes
            if (attrs.legalName && !details.name) {
              details.name = attrs.legalName;
            }
            if (attrs.organizationName && !details.name) {
              details.name = attrs.organizationName;
            }
            if (attrs.role && !details.role) {
              details.role = attrs.role;
            }
            if (attrs.lids && attrs.lids.length > 0 && !details.lei) {
              details.lei = attrs.lids[0];
            }
            if (attrs.LEI && !details.lei) {
              details.lei = attrs.LEI;
            }
          }

          // Track which credentials this issuer has issued
          if (acdc.i === issuerAid) {
            details.credentials.push({
              said: acdc.d,
              schema: acdc.s
            });
          }
        }

        return details;
      }

      // Format issuer display with details
      function formatIssuerDisplay(issuerAid, allAcdcs) {
        const details = findIssuerDetails(issuerAid, allAcdcs);
        const shortAid = issuerAid ? issuerAid.substring(0, 24) + '...' : 'Unknown';

        let html = '<div class="issuer-details" style="display:flex;flex-direction:column;gap:2px;">';

        // Organization name (if found)
        if (details.name) {
          html += `<span style="font-weight:bold;color:#2c5282;">${details.name}</span>`;
        }

        // Role (if found)
        if (details.role) {
          html += `<span style="font-size:0.85em;color:#666;font-style:italic;">${details.role}</span>`;
        }

        // LEI (if found)
        if (details.lei) {
          html += `<span style="font-size:0.8em;color:#666;">LEI: ${details.lei}</span>`;
        }

        // AID with expand/copy functionality
        html += `<details style="margin-top:2px;">`;
        html += `<summary style="cursor:pointer;font-family:monospace;font-size:0.85em;color:#555;">${shortAid}</summary>`;
        html += `<div style="margin-top:4px;padding:4px;background:#f0f0f0;border-radius:2px;">`;
        html += `<code style="font-size:0.75em;word-break:break-all;display:block;margin-bottom:4px;">${issuerAid}</code>`;
        html += `<button onclick="navigator.clipboard.writeText('${issuerAid}');this.textContent='Copied!';setTimeout(()=>this.textContent='Copy AID',1500)" style="font-size:0.7em;padding:2px 6px;cursor:pointer;">Copy AID</button>`;
        html += `</div></details>`;

        // Credential count (if issuer has issued multiple)
        if (details.credentials.length > 1) {
          html += `<span style="font-size:0.75em;color:#888;">Issued ${details.credentials.length} credentials in this dossier</span>`;
        }

        html += '</div>';
        return html;
      }

      // Extract key claims from attributes for summary
      function extractKeyClaims(attrs) {
        if (!attrs || typeof attrs !== 'object') return [];
        const claims = [];

        // Phone numbers
        if (attrs.numbers) {
          const range = attrs.numbers.rangeStart === attrs.numbers.rangeEnd
            ? attrs.numbers.rangeStart
            : `${attrs.numbers.rangeStart} - ${attrs.numbers.rangeEnd}`;
          claims.push({ label: 'Phone Number', value: range, icon: 'üìû' });
        }

        // Role
        if (attrs.role) {
          claims.push({ label: 'Role', value: attrs.role, icon: 'üë§' });
        }

        // LEI
        if (attrs.lids && attrs.lids.length > 0) {
          claims.push({ label: 'LEI', value: attrs.lids.join(', '), icon: 'üè¢' });
        }

        // vCard parsing
        if (attrs.vcard && Array.isArray(attrs.vcard)) {
          for (const line of attrs.vcard) {
            if (line.startsWith('ORG:')) {
              claims.push({ label: 'Organization', value: line.substring(4), icon: 'üè¢' });
            }
            if (line.includes('LEI:')) {
              const lei = line.match(/LEI:([A-Z0-9]+)/);
              if (lei) claims.push({ label: 'LEI', value: lei[1], icon: 'üìã' });
            }
            if (line.includes('LOGO;')) {
              const url = line.match(/VALUE=URI:(.+)$/);
              if (url) claims.push({ label: 'Logo', value: url[1], icon: 'üñºÔ∏è', isUrl: true });
            }
          }
        }

        // Dates
        if (attrs.startDate || attrs.endDate) {
          const range = `${attrs.startDate || '?'} to ${attrs.endDate || '?'}`;
          claims.push({ label: 'Valid Period', value: range, icon: 'üìÖ' });
        }

        // Geographic constraints
        if (attrs.c_pgeo) {
          claims.push({ label: 'Permitted Geo', value: attrs.c_pgeo.join(', '), icon: 'üåç' });
        }

        return claims;
      }

      // Format ACDC claims for display - now uses unified card renderer
      function formatACDC(acdc, index, revocationStatus, allAcdcs) {
        // Convert inline TEL revocation status to unified format
        let unifiedStatus = null;
        if (revocationStatus) {
          unifiedStatus = {
            status: revocationStatus.status === 'revoked' ? 'REVOKED' : (revocationStatus.status === 'issued' ? 'ACTIVE' : 'UNKNOWN'),
            issuance: revocationStatus.issuanceEvent,
            revocation: revocationStatus.revocationEvent
          };
        }

        // Use unified card renderer
        let html = renderCredentialCard(acdc, {
          compact: false,
          showFullDetails: true,
          revocationStatus: unifiedStatus,
          allAcdcs: allAcdcs
        });

        // Add action buttons after the card
        html = html.replace('</div>$', '');  // Remove last closing div temporarily

        // Find position to insert buttons (before the last </div>)
        const insertPos = html.lastIndexOf('</div>');
        const beforeButtons = html.substring(0, insertPos);
        const afterButtons = html.substring(insertPos);

        let buttonsHtml = `<div style="margin-top:0.5rem;display:flex;gap:0.5rem;flex-wrap:wrap;border-top:1px solid rgba(0,0,0,0.1);padding-top:0.5rem;">`;

        // View Chain button (only for non-root credentials with edges)
        if (acdc.e && Object.keys(acdc.e).filter(k => k !== 'd' && k !== 'n').length > 0) {
          buttonsHtml += `<button onclick="showCredentialGraph('${acdc.d}')" style="font-size:0.85em;padding:4px 8px;cursor:pointer;background:#0066cc;color:white;border:none;border-radius:4px;">üîó View Chain</button>`;
        }

        buttonsHtml += `</div>`;

        return beforeButtons + buttonsHtml + afterButtons;
      }

      // Parse JWT button
      document.getElementById("parseJwtBtn").addEventListener("click", () => {
        const jwt = document.getElementById("jwt").value;
        parseAndDisplayJwt(jwt);
      });

      // Parse SIP INVITE button
      document.getElementById("parseSipBtn").addEventListener("click", () => {
        const sipInvite = document.getElementById("sipInvite").value;
        const output = document.getElementById("parsedOutput");

        // Find Identity header (case-insensitive)
        const lines = sipInvite.split(/\r?\n/);
        let identityValue = null;

        for (const line of lines) {
          const match = line.match(/^Identity:\s*(.+)/i);
          if (match) {
            identityValue = match[1].trim();
            break;
          }
        }

        if (!identityValue) {
          output.textContent = "Error: No Identity header found in SIP INVITE";
          document.getElementById("dossierSection").style.display = "none";
          return;
        }

        // Populate the JWT textarea and parse
        document.getElementById("jwt").value = identityValue;
        parseAndDisplayJwt(identityValue);
      });

      // Extract JSON objects from CESR stream by version prefix
      function extractJsonFromCESR(rawText, versionPrefix) {
        const objects = [];
        let pos = 0;
        while ((pos = rawText.indexOf(`{"v":"${versionPrefix}`, pos)) !== -1) {
          try {
            let depth = 0;
            let start = pos;
            let end = pos;

            for (let i = pos; i < rawText.length; i++) {
              if (rawText[i] === '{') depth++;
              else if (rawText[i] === '}') {
                depth--;
                if (depth === 0) {
                  end = i + 1;
                  break;
                }
              }
            }

            const jsonStr = rawText.substring(start, end);
            const obj = JSON.parse(jsonStr);
            objects.push(obj);
            pos = end;
          } catch (e) {
            pos++;
          }
        }
        return objects;
      }

      // Extract ACDCs from CESR stream
      function extractACDCsFromCESR(data) {
        let rawText = typeof data === 'string' ? data :
                      (data.details ? data.details : JSON.stringify(data));
        return extractJsonFromCESR(rawText, 'ACDC');
      }

      // Extract TEL (Transaction Event Log) events from CESR stream
      // TEL events track credential issuance and revocation
      function extractTELFromCESR(data) {
        let rawText = typeof data === 'string' ? data :
                      (data.details ? data.details : JSON.stringify(data));

        const telEvents = [];

        // TEL events use KERI version strings with specific event types:
        // - iss: issuance event
        // - rev: revocation event
        // - bis: backers issuance (delegated)
        // - brv: backers revocation (delegated)
        const keriEvents = extractJsonFromCESR(rawText, 'KERI');

        for (const event of keriEvents) {
          // TEL events have 't' field indicating type
          if (event.t && ['iss', 'rev', 'bis', 'brv'].includes(event.t)) {
            telEvents.push(event);
          }
        }

        return telEvents;
      }

      // Build revocation status map from TEL events
      // Returns: { credentialSAID: { status: 'issued'|'revoked', event: {...} } }
      function buildRevocationMap(telEvents) {
        const statusMap = {};

        // Sort events by sequence number (s field) to process in order
        const sorted = [...telEvents].sort((a, b) => {
          const seqA = parseInt(a.s) || 0;
          const seqB = parseInt(b.s) || 0;
          return seqA - seqB;
        });

        for (const event of sorted) {
          // TEL events reference the credential via:
          // - 'i' field: registry identifier
          // - 'ri' field: registry identifier (alternate)
          // - The credential SAID is typically derived from context

          // For issuance events (iss, bis): credential is being issued
          // The 'i' field in iss event IS the credential SAID
          if (event.t === 'iss' || event.t === 'bis') {
            const credSaid = event.i;
            if (credSaid) {
              statusMap[credSaid] = {
                status: 'issued',
                issuanceEvent: event,
                registry: event.ri || event.i
              };
            }
          }

          // For revocation events (rev, brv): credential is being revoked
          // The 'i' field references the credential being revoked
          if (event.t === 'rev' || event.t === 'brv') {
            const credSaid = event.i;
            if (credSaid && statusMap[credSaid]) {
              statusMap[credSaid].status = 'revoked';
              statusMap[credSaid].revocationEvent = event;
            } else if (credSaid) {
              // Revocation without prior issuance in stream
              statusMap[credSaid] = {
                status: 'revoked',
                revocationEvent: event,
                registry: event.ri
              };
            }
          }
        }

        return statusMap;
      }

      // Get revocation status for an ACDC
      function getRevocationStatus(acdc, revocationMap) {
        // Check by ACDC SAID
        if (acdc.d && revocationMap[acdc.d]) {
          return revocationMap[acdc.d];
        }

        // Check by registry identifier if present
        if (acdc.ri) {
          // Look for any status entry matching this registry
          for (const [said, status] of Object.entries(revocationMap)) {
            if (status.registry === acdc.ri) {
              return status;
            }
          }
        }

        return null; // No TEL data found
      }

      // Helper to display dossier data
      async function displayDossier(data, contentType, autoCheckRevocation = true) {
        const output = document.getElementById("dossierOutput");

        let acdcs = [];
        let telEvents = [];
        let revocationMap = {};

        // Check if it's CESR format (has "details" key or is a string with KERI/ACDC data)
        if (data.details || (typeof data === 'string' && data.includes('KERI10JSON'))) {
          acdcs = extractACDCsFromCESR(data);
          telEvents = extractTELFromCESR(data);
          revocationMap = buildRevocationMap(telEvents);
        } else if (Array.isArray(data)) {
          acdcs = data;
        } else if (data.d && data.i) {
          // Single ACDC object
          acdcs = [data];
        }

        // Deduplicate by SAID
        const seen = new Set();
        const uniqueAcdcs = [];
        for (const acdc of acdcs) {
          if (acdc.d && !seen.has(acdc.d)) {
            seen.add(acdc.d);
            uniqueAcdcs.push(acdc);
          }
        }
        const duplicateCount = acdcs.length - uniqueAcdcs.length;
        acdcs = uniqueAcdcs;

        // Store ACDCs globally
        currentAcdcs = acdcs;
        currentOobiUrl = currentEvdUrl;

        // Show verify section if we have a JWT
        if (currentPassportJwt) {
          document.getElementById("verifySection").style.display = "block";
        }

        // Convert inline TEL revocation map to unified format and store globally
        currentRevocationStatus = {};
        for (const [said, status] of Object.entries(revocationMap)) {
          currentRevocationStatus[said] = {
            status: status.status === 'revoked' ? 'REVOKED' : (status.status === 'issued' ? 'ACTIVE' : 'UNKNOWN'),
            issuance: status.issuanceEvent,
            revocation: status.revocationEvent,
            source: 'inline_tel'
          };
        }

        // Render initial display
        renderDossierView(acdcs, telEvents, revocationMap, contentType, duplicateCount, data);

        // Auto-check revocation for ACDCs without inline TEL status
        if (autoCheckRevocation && acdcs.length > 0) {
          const acdcsNeedingCheck = acdcs.filter(acdc => !revocationMap[acdc.d]);
          if (acdcsNeedingCheck.length > 0) {
            console.log(`Auto-checking revocation for ${acdcsNeedingCheck.length} ACDCs...`);
            await autoCheckRevocationStatus(acdcsNeedingCheck);
            // Re-render with updated status
            renderDossierView(acdcs, telEvents, revocationMap, contentType, duplicateCount, data);
          }
        }
      }

      // Render the dossier view (separated for re-rendering after revocation check)
      function renderDossierView(acdcs, telEvents, revocationMap, contentType, duplicateCount, rawData) {
        const output = document.getElementById("dossierOutput");
        let html = `<p><strong>Content-Type:</strong> ${contentType || 'application/json'}</p>`;

        // Show TEL summary
        if (telEvents.length > 0) {
          const issCount = telEvents.filter(e => e.t === 'iss' || e.t === 'bis').length;
          const revCount = telEvents.filter(e => e.t === 'rev' || e.t === 'brv').length;
          html += `<p style="background:#e8e8ff;padding:0.5rem;border-radius:4px;font-size:0.9em;">`;
          html += `<strong>üìã Inline TEL Events:</strong> ${telEvents.length} total (${issCount} issuance, ${revCount} revocation)`;
          html += `</p>`;
        }

        // Show live revocation check summary
        const liveChecks = Object.values(currentRevocationStatus).filter(s => s.source === 'live_witness');
        if (liveChecks.length > 0) {
          const activeCount = liveChecks.filter(s => s.status === 'ACTIVE').length;
          const revokedCount = liveChecks.filter(s => s.status === 'REVOKED').length;
          const unknownCount = liveChecks.filter(s => s.status === 'UNKNOWN').length;
          html += `<p style="background:#d4edda;padding:0.5rem;border-radius:4px;font-size:0.9em;">`;
          html += `<strong>üîç Live Revocation Check:</strong> `;
          if (activeCount > 0) html += `<span style="color:#28a745;">${activeCount} active</span> `;
          if (revokedCount > 0) html += `<span style="color:#dc3545;">${revokedCount} revoked</span> `;
          if (unknownCount > 0) html += `<span style="color:#ffc107;">${unknownCount} unknown</span>`;
          html += `</p>`;
        } else if (acdcs.length > 0 && telEvents.length === 0) {
          html += `<p style="background:#fff3cd;padding:0.5rem;border-radius:4px;font-size:0.9em;" id="revocationCheckStatus">`;
          html += `<strong>‚è≥ Checking revocation status...</strong> Querying KERI witnesses...`;
          html += `</p>`;
        }

        if (duplicateCount > 0) {
          html += `<p style="color:#666;font-size:0.9em;">(${duplicateCount} duplicate ACDC(s) removed)</p>`;
        }

        if (acdcs.length === 0) {
          html += `<p style="color:orange;">No ACDCs found in dossier. Raw data shown below.</p>`;
          document.getElementById("checkRevocationBtn").disabled = true;
        } else {
          document.getElementById("checkRevocationBtn").disabled = false;

          html += `<div style="display:flex;align-items:center;gap:1rem;margin-bottom:0.5rem;flex-wrap:wrap;">`;
          html += `<p style="margin:0;"><strong>Found ${acdcs.length} ACDC(s) in dossier:</strong></p>`;
          html += `<button onclick="showCredentialGraph(null)" style="font-size:0.85em;padding:4px 12px;cursor:pointer;background:#0066cc;color:white;border:none;border-radius:4px;">üîó View Full Chain Graph</button>`;
          html += `</div>`;

          for (let i = 0; i < acdcs.length; i++) {
            // Prefer live status, fall back to inline TEL
            const revStatus = currentRevocationStatus[acdcs[i].d] || getRevocationStatus(acdcs[i], revocationMap);
            html += formatACDC(acdcs[i], i, revStatus, acdcs);
          }
        }

        // Show TEL events in collapsible section
        if (telEvents.length > 0) {
          html += `<details style="margin-top:1rem;"><summary style="cursor:pointer;"><strong>TEL Events (${telEvents.length})</strong></summary>`;
          html += `<div style="background:#f0f0ff;padding:0.5rem;border-radius:4px;margin-top:0.5rem;">`;
          for (const event of telEvents) {
            const typeLabel = {
              'iss': '‚úÖ Issuance',
              'rev': 'üö´ Revocation',
              'bis': '‚úÖ Backers Issuance',
              'brv': 'üö´ Backers Revocation'
            }[event.t] || event.t;
            html += `<div style="margin:4px 0;padding:4px;background:#fff;border-radius:2px;font-size:0.85em;">`;
            html += `<strong>${typeLabel}</strong> - SAID: ${event.i ? event.i.substring(0, 20) + '...' : 'N/A'}`;
            if (event.dt) html += ` - Date: ${event.dt}`;
            if (event.s !== undefined) html += ` - Seq: ${event.s}`;
            html += `</div>`;
          }
          html += `</div></details>`;
        }

        // Show raw data
        const rawDisplay = typeof rawData === 'string' ? rawData : JSON.stringify(rawData, null, 2);
        html += `<details style="margin-top:1rem;"><summary>Raw Data</summary><pre style="background:#fff;padding:0.5rem;overflow:auto;max-height:400px;font-size:0.75em;">${rawDisplay.substring(0, 50000)}${rawDisplay.length > 50000 ? '...(truncated)' : ''}</pre></details>`;

        output.innerHTML = html;
      }

      // Automatically check revocation status for ACDCs
      async function autoCheckRevocationStatus(acdcs) {
        const results = [];

        for (const acdc of acdcs) {
          try {
            const res = await fetch("/check-revocation", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                credential_said: acdc.d,
                registry_said: acdc.ri || null,
                oobi_url: currentOobiUrl,
                kid_url: currentKidUrl,
                dossier_stream: currentDossierStream
              })
            });

            const result = await res.json();

            // Store result in global status map
            currentRevocationStatus[acdc.d] = {
              status: result.status || 'UNKNOWN',
              issuance: result.issuance,
              revocation: result.revocation,
              source: 'live_witness',
              error: result.error
            };

            results.push({ acdc, result });
          } catch (e) {
            currentRevocationStatus[acdc.d] = {
              status: 'UNKNOWN',
              source: 'live_witness',
              error: e.message
            };
            results.push({ acdc, result: { success: false, status: 'ERROR', error: e.message } });
          }
        }

        console.log('Auto revocation check complete:', results);
        return results;
      }

      // Load mock dossier
      document.getElementById("mockDossierBtn").addEventListener("click", async () => {
        const output = document.getElementById("dossierOutput");
        output.innerHTML = "<em>Loading mock dossier...</em>";

        try {
          const res = await fetch("/mock-dossier");
          const data = await res.json();
          await displayDossier(data, "application/json (mock)");
        } catch (e) {
          output.innerHTML = `<span style="color:red;">Error loading mock: ${e.message}</span>`;
        }
      });

      // Fetch and display dossier
      document.getElementById("fetchDossierBtn").addEventListener("click", async () => {
        const output = document.getElementById("dossierOutput");

        if (!currentEvdUrl) {
          output.innerHTML = "<em>No evd URL available</em>";
          return;
        }

        output.innerHTML = "<em>Fetching dossier...</em>";

        try {
          const res = await fetch("/proxy-fetch", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ url: currentEvdUrl })
          });

          const result = await res.json();

          if (!result.success) {
            output.innerHTML = `<span style="color:red;">Error: ${result.error}</span>`;
            return;
          }

          // Store raw dossier for inline TEL parsing (Phase 9.4)
          currentDossierStream = typeof result.data === 'string' ? result.data : JSON.stringify(result.data);
          await displayDossier(result.data, result.content_type);

        } catch (e) {
          output.innerHTML = `<span style="color:orange;">Could not fetch dossier: ${e.message}</span><br><br>` +
            `<strong>To fetch dossiers, run the server:</strong><br>` +
            `<code>python3 web/server.py</code><br><br>` +
            `<strong>Or fetch manually:</strong><br>` +
            `<code>curl "${currentEvdUrl}"</code>`;
        }
      });

      // Check live revocation status from KERI witnesses
      document.getElementById("checkRevocationBtn").addEventListener("click", async () => {
        const btn = document.getElementById("checkRevocationBtn");
        const originalText = btn.textContent;
        btn.textContent = "Checking...";
        btn.disabled = true;

        const results = [];

        for (const acdc of currentAcdcs) {
          try {
            const res = await fetch("/check-revocation", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                credential_said: acdc.d,
                registry_said: acdc.ri || null,
                oobi_url: currentOobiUrl,
                kid_url: currentKidUrl,  // Witness OOBI from JWT kid field
                dossier_stream: currentDossierStream  // Pass raw dossier for inline TEL
              })
            });

            const result = await res.json();
            results.push({
              acdc: acdc,
              result: result
            });
          } catch (e) {
            results.push({
              acdc: acdc,
              result: { success: false, status: "ERROR", error: e.message }
            });
          }
        }

        // Display results
        displayLiveRevocationResults(results);

        btn.textContent = originalText;
        btn.disabled = false;
      });

      // Show credential graph for a specific ACDC
      async function showCredentialGraph(startingSaid) {
        console.log("Building graph with", currentAcdcs?.length, "ACDCs");
        console.log("First ACDC:", currentAcdcs?.[0]);

        // Build dossier data from current ACDCs
        const dossierData = {
          dossier: {
            acdcs: currentAcdcs
          }
        };

        // Show loading modal
        showGraphModal('<div style="text-align:center;padding:2rem;"><em>Building credential graph...</em></div>');

        try {
          const res = await fetch("/credential-graph", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(dossierData)
          });

          if (!res.ok) {
            throw new Error(`HTTP ${res.status}: ${await res.text()}`);
          }

          const response = await res.json();
          console.log("Credential graph response:", response);

          // Handle both direct graph response and wrapped {success, graph} response
          const graph = response.graph || response;
          console.log("Nodes:", graph.nodes?.length, "Layers:", graph.layers?.length);
          renderCredentialGraph(graph, startingSaid);
        } catch (e) {
          showGraphModal(`<div style="color:red;padding:1rem;">Error building graph: ${e.message}</div>`);
        }
      }

      // Show the graph modal
      function showGraphModal(content) {
        // Remove existing modal if any
        const existing = document.getElementById('graphModal');
        if (existing) existing.remove();

        const modal = document.createElement('div');
        modal.id = 'graphModal';
        modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);display:flex;justify-content:center;align-items:center;z-index:1000;';
        modal.innerHTML = `
          <div style="background:white;border-radius:8px;max-width:90%;max-height:90%;overflow:auto;position:relative;">
            <button onclick="document.getElementById('graphModal').remove()" style="position:absolute;top:8px;right:8px;background:#dc3545;color:white;border:none;border-radius:50%;width:28px;height:28px;cursor:pointer;font-size:16px;">√ó</button>
            <div id="graphContent" style="padding:1rem;">${content}</div>
          </div>
        `;
        document.body.appendChild(modal);

        // Close on background click
        modal.addEventListener('click', (e) => {
          if (e.target === modal) modal.remove();
        });
      }

      // Render the credential graph using unified credential cards
      function renderCredentialGraph(graph, highlightSaid) {
        let html = `<div style="min-width:600px;">`;
        html += `<h3 style="margin-top:0;">üîó Credential Chain Graph</h3>`;

        // Trust path indicator
        if (graph.trustPathValid) {
          html += `<div style="background:#d4edda;color:#155724;padding:0.5rem;border-radius:4px;margin-bottom:1rem;">‚úÖ Valid trust path to root</div>`;
        } else {
          html += `<div style="background:#f8d7da;color:#721c24;padding:0.5rem;border-radius:4px;margin-bottom:1rem;">‚ö†Ô∏è No valid trust path to root (issuer not in trusted roots list)</div>`;
        }

        // Render layers (root first, then children)
        if (!graph.layers || graph.layers.length === 0) {
          if (graph.nodes && graph.nodes.length > 0) {
            html += `<div style="background:#fff3cd;padding:0.5rem;border-radius:4px;">No layers computed, but ${graph.nodes.length} nodes exist.</div>`;
          } else {
            html += `<div style="background:#f8d7da;padding:0.5rem;border-radius:4px;">No credentials found in graph.</div>`;
          }
        }

        if (graph.layers && graph.layers.length > 0) {
          html += `<div style="display:flex;flex-direction:column;gap:1rem;">`;

          for (let layerIdx = 0; layerIdx < graph.layers.length; layerIdx++) {
            const layer = graph.layers[layerIdx];
            // Determine layer label based on contents
            let layerLabel;
            if (layerIdx === 0) {
              const hasRoot = layer.some(id => graph.nodes.find(n => n.id === id)?.isRoot);
              layerLabel = hasRoot ? 'üèõÔ∏è Root of Trust' : 'üîì Chain Terminus (Untrusted Issuer)';
            } else {
              layerLabel = `Layer ${layerIdx} - Issued Credentials`;
            }

            html += `<div style="border-left:3px solid #0066cc;padding-left:1rem;">`;
            html += `<div style="font-size:0.85em;color:#555;margin-bottom:0.5rem;font-weight:bold;">${layerLabel}</div>`;
            html += `<div style="display:flex;flex-wrap:wrap;gap:0.75rem;">`;

            for (const nodeId of layer) {
              const node = graph.nodes.find(n => n.id === nodeId);
              if (!node) continue;

              // Find the original ACDC for this node to get full attributes
              const originalAcdc = currentAcdcs.find(a => a.d === node.id);

              // Build credential object for unified card renderer
              const credential = {
                d: node.id,
                i: node.issuer,
                s: node.schemaSaid,
                type: node.type,
                displayName: node.displayName,
                status: currentRevocationStatus[node.id]?.status || node.status,
                isRoot: node.isRoot,
                // Include original ACDC data if available
                a: originalAcdc?.a || node.attributes || {},
                // Use original edges, or node edges from graph, or convert edgesTo array
                e: originalAcdc?.e || node.edges || {},
              };

              // Convert edgesTo array to edges object format if no edges object
              if ((!credential.e || Object.keys(credential.e).length === 0) && node.edgesTo && node.edgesTo.length > 0) {
                credential.e = {};
                for (let i = 0; i < node.edgesTo.length; i++) {
                  credential.e[`link${i}`] = { n: node.edgesTo[i] };
                }
              }

              // Get revocation status from our cache
              const revStatus = currentRevocationStatus[node.id] || null;

              // Use unified card renderer in compact mode
              html += renderCredentialCard(credential, {
                compact: true,
                showFullDetails: false,
                highlightId: highlightSaid,
                revocationStatus: revStatus,
                allAcdcs: currentAcdcs
              });
            }

            html += `</div></div>`;

            // Draw connector arrows between layers
            if (layerIdx < graph.layers.length - 1) {
              html += `<div style="text-align:center;color:#999;font-size:1.5em;">‚Üì</div>`;
            }
          }

          html += `</div>`;
        }

        // Show any errors
        if (graph.errors && graph.errors.length > 0) {
          html += `<div style="background:#fff3cd;padding:0.5rem;border-radius:4px;margin-top:1rem;">`;
          html += `<strong>‚ö†Ô∏è Warnings:</strong><ul style="margin:0.5rem 0 0 1rem;padding:0;">`;
          for (const err of graph.errors) {
            html += `<li style="font-size:0.85em;">${err}</li>`;
          }
          html += `</ul></div>`;
        }

        // Legend
        html += `<div style="margin-top:1rem;padding-top:1rem;border-top:1px solid #eee;font-size:0.8em;color:#666;">`;
        html += `<strong>Legend:</strong> `;
        html += `<span style="display:inline-block;width:12px;height:12px;background:#e8f4ff;border:2px solid #0066cc;margin-right:4px;"></span>Trusted Root `;
        html += `<span style="display:inline-block;width:12px;height:12px;background:#f8f9fa;border:2px solid #6c757d;margin-right:4px;margin-left:8px;"></span>Untrusted Issuer `;
        html += `<span style="display:inline-block;width:12px;height:12px;background:#f5fff5;border:2px solid #28a745;margin-right:4px;margin-left:8px;"></span>Active `;
        html += `<span style="display:inline-block;width:12px;height:12px;background:#fff5f5;border:2px solid #dc3545;margin-right:4px;margin-left:8px;"></span>Revoked `;
        html += `<span style="display:inline-block;width:12px;height:12px;background:#fff;border:2px solid #ffc107;margin-right:4px;margin-left:8px;"></span>Unknown Status `;
        html += `</div>`;

        html += `</div>`;

        showGraphModal(html);
      }

      // Get type badge HTML
      function getTypeBadge(type) {
        const badges = {
          'ROOT': '<span style="background:#0066cc;color:white;padding:2px 6px;border-radius:4px;font-size:0.75em;">üèõÔ∏è TRUSTED ROOT</span>',
          'ISSUER': '<span style="background:#6c757d;color:white;padding:2px 6px;border-radius:4px;font-size:0.75em;">üîì ISSUER (Untrusted)</span>',
          'LE': '<span style="background:#28a745;color:white;padding:2px 6px;border-radius:4px;font-size:0.75em;">üè¢ Legal Entity</span>',
          'APE': '<span style="background:#17a2b8;color:white;padding:2px 6px;border-radius:4px;font-size:0.75em;">üì± Auth Phone</span>',
          'DE': '<span style="background:#fd7e14;color:white;padding:2px 6px;border-radius:4px;font-size:0.75em;">üë§ Delegate</span>',
          'TNAlloc': '<span style="background:#6f42c1;color:white;padding:2px 6px;border-radius:4px;font-size:0.75em;">üìû TN Alloc</span>',
          'VetterCert': '<span style="background:#e83e8c;color:white;padding:2px 6px;border-radius:4px;font-size:0.75em;">üåç Vetter Cert</span>',
          'Constrained': '<span style="background:#20c997;color:white;padding:2px 6px;border-radius:4px;font-size:0.75em;">üîí Constrained</span>',
        };
        return badges[type] || `<span style="background:#999;color:white;padding:2px 6px;border-radius:4px;font-size:0.75em;">${type}</span>`;
      }

      // Unified credential card renderer
      // Used in both dossier view and graph view
      // revocationStatus: { status: 'ACTIVE'|'REVOKED'|'UNKNOWN', issuance?: {...}, revocation?: {...} }
      function renderCredentialCard(credential, options = {}) {
        const {
          compact = false,           // Compact view for graph
          showFullDetails = true,    // Show expandable full details
          highlightId = null,        // Highlight if matches this ID
          onLinkClick = null,        // Callback when clicking credential link
          revocationStatus = null,   // Revocation status object
          allAcdcs = []              // All ACDCs for issuer lookup
        } = options;

        // Determine credential type from various sources
        let credType = credential.type || credential.credential_type || 'unknown';
        const attrs = credential.a || credential.attributes || {};
        const edges = credential.e || credential.edges || {};

        // Better type detection
        if (credType === 'unknown') {
          // Check attributes for type hints
          if (attrs.LEI || attrs.lids) credType = 'LE';
          else if (attrs.phone || attrs.tn || attrs.numbers) credType = 'TNAlloc';
          // Vetter Certification credentials (Sprint 40)
          else if (attrs.ecc_targets || attrs.jurisdiction_targets) credType = 'VetterCert';
          // Check edges for type hints
          else if (edges.vetting || edges.le) credType = 'APE';
          else if (edges.delegation) credType = 'DE';
          // Check for certification edge (indicates vetter-constrained credential)
          else if (edges.certification || edges.vetter || edges.vetter_cert || edges.cert) credType = 'Constrained';
        }

        // Get key identifiers
        const said = credential.d || credential.id || credential.said || '';
        const issuerAid = credential.i || credential.issuer || credential.issuer_aid || '';
        const schemaSaid = credential.s || credential.schema_said || credential.schemaSaid || '';
        const registrySaid = credential.ri || credential.registry_said || '';

        // Determine styling based on status
        let borderColor = '#ccc';
        let bgColor = '#fafafa';
        const isHighlighted = highlightId && said === highlightId;

        // Status from revocation check or from graph node
        const status = revocationStatus?.status || credential.status || 'UNKNOWN';

        if (credential.isRoot) {
          borderColor = '#0066cc';
          bgColor = '#e8f4ff';
        } else if (credType === 'ISSUER') {
          borderColor = '#6c757d';
          bgColor = '#f8f9fa';
        } else if (status === 'REVOKED') {
          borderColor = '#dc3545';
          bgColor = '#fff5f5';
        } else if (status === 'ACTIVE') {
          borderColor = '#28a745';
          bgColor = '#f5fff5';
        }

        if (isHighlighted) {
          borderColor = '#ffc107';
        }

        // Build card HTML
        const padding = compact ? '0.5rem' : '1rem';
        const minWidth = compact ? '220px' : '100%';
        const maxWidth = compact ? '320px' : '100%';

        let html = `<div class="credential-card" data-said="${said}" style="border:2px solid ${borderColor};background:${bgColor};padding:${padding};border-radius:4px;${compact ? `min-width:${minWidth};max-width:${maxWidth};` : 'margin-bottom:1rem;'}">`;

        // Header: Type badge + Status
        html += `<div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:0.5rem;flex-wrap:wrap;gap:0.25rem;">`;
        html += getTypeBadge(credType);

        // Status badge
        if (status === 'REVOKED') {
          html += `<span style="background:#dc3545;color:white;padding:2px 8px;border-radius:12px;font-size:0.75em;">üö´ REVOKED</span>`;
        } else if (status === 'ACTIVE') {
          html += `<span style="background:#28a745;color:white;padding:2px 8px;border-radius:12px;font-size:0.75em;">‚úì ACTIVE</span>`;
        } else {
          html += `<span style="background:#ffc107;color:#000;padding:2px 8px;border-radius:12px;font-size:0.75em;">‚ö† UNKNOWN</span>`;
        }
        html += `</div>`;

        // Display name / Title
        let displayName = credential.displayName || '';
        if (!displayName) {
          displayName = generateDisplayName(credType, attrs);
        }
        html += `<div style="font-weight:bold;font-size:${compact ? '0.9em' : '1em'};margin-bottom:0.5rem;word-break:break-word;">${displayName}</div>`;

        // Key attributes section
        const keyAttrs = extractAllAttributes(attrs, credential);
        if (keyAttrs.length > 0 && !compact) {
          html += `<div style="background:rgba(255,255,255,0.7);padding:0.5rem;border-radius:4px;margin-bottom:0.5rem;font-size:0.9em;">`;
          for (const attr of keyAttrs) {
            if (attr.isUrl) {
              html += `<div style="margin:2px 0;"><strong>${attr.label}:</strong> <a href="${attr.value}" target="_blank" style="word-break:break-all;color:#0066cc;">${truncate(attr.value, 50)}</a></div>`;
            } else {
              html += `<div style="margin:2px 0;"><strong>${attr.label}:</strong> ${attr.value}</div>`;
            }
          }
          html += `</div>`;
        } else if (keyAttrs.length > 0 && compact) {
          // Show just top 2 attributes in compact mode
          html += `<div style="font-size:0.8em;color:#555;margin-bottom:0.5rem;">`;
          for (let i = 0; i < Math.min(2, keyAttrs.length); i++) {
            html += `<div>${keyAttrs[i].label}: ${truncate(keyAttrs[i].value, 30)}</div>`;
          }
          html += `</div>`;
        }

        // Revocation event details (if available)
        if (revocationStatus && !compact) {
          if (revocationStatus.issuance) {
            const dt = revocationStatus.issuance.datetime || revocationStatus.issuance.dt || 'Unknown';
            html += `<div style="font-size:0.85em;color:#28a745;">üìÖ Issued: ${dt}</div>`;
          }
          if (revocationStatus.revocation) {
            const dt = revocationStatus.revocation.datetime || revocationStatus.revocation.dt || 'Unknown';
            html += `<div style="font-size:0.85em;color:#dc3545;">üö´ Revoked: ${dt}</div>`;
          }
        }

        // Issuer info
        if (issuerAid && !credential.isRoot && !compact) {
          const issuerDetails = findIssuerDetails(issuerAid, allAcdcs);
          html += `<div style="font-size:0.85em;margin-top:0.5rem;">`;
          html += `<strong>Issuer:</strong> `;
          if (issuerDetails.name) {
            html += `${issuerDetails.name} `;
          }
          html += `<code style="font-size:0.85em;">${truncate(issuerAid, 20)}</code>`;
          html += `</div>`;
        }

        // Credential links (edges)
        const edgeKeys = Object.keys(edges).filter(k => k !== 'd' && k !== 'n');
        if (edgeKeys.length > 0) {
          html += `<div style="margin-top:0.5rem;font-size:${compact ? '0.8em' : '0.9em'};">`;
          html += `<strong>Links to:</strong>`;
          html += `<div style="margin-left:0.5rem;">`;
          for (const edgeName of edgeKeys) {
            const edge = edges[edgeName];
            const targetSaid = typeof edge === 'string' ? edge : (edge?.n || edge?.d || '');
            if (targetSaid) {
              const linkStyle = onLinkClick
                ? 'cursor:pointer;color:#0066cc;text-decoration:underline;'
                : '';
              html += `<div style="margin:2px 0;" class="credential-link" data-target="${targetSaid}">`;
              html += `üîó <em>${edgeName}</em>: `;
              html += `<span style="${linkStyle}" onclick="handleCredentialLinkClick('${targetSaid}')">${truncate(targetSaid, 16)}</span>`;
              html += `</div>`;
            }
          }
          html += `</div></div>`;
        }

        // SAID footer
        if (!credential.isRoot) {
          html += `<div style="font-size:0.7em;color:#999;font-family:monospace;margin-top:0.5rem;border-top:1px solid rgba(0,0,0,0.1);padding-top:0.25rem;">`;
          html += `SAID: ${truncate(said, compact ? 12 : 24)}`;
          if (!compact) {
            html += ` <button onclick="navigator.clipboard.writeText('${said}');this.textContent='Copied!';setTimeout(()=>this.textContent='Copy',1500)" style="font-size:0.9em;padding:1px 4px;cursor:pointer;">Copy</button>`;
          }
          html += `</div>`;
        }

        // Full details expandable (non-compact only)
        if (showFullDetails && !compact) {
          html += `<details style="margin-top:0.5rem;"><summary style="cursor:pointer;font-size:0.85em;color:#666;">Full Details</summary>`;
          html += `<pre style="background:#fff;padding:0.5rem;overflow:auto;font-size:0.75em;max-height:200px;margin-top:0.25rem;">${JSON.stringify(credential, null, 2)}</pre>`;
          html += `</details>`;
        }

        html += `</div>`;
        return html;
      }

      // Generate display name from type and attributes
      function generateDisplayName(credType, attrs) {
        if (credType === 'LE') {
          const lei = attrs.LEI || (attrs.lids && attrs.lids[0]) || '';
          if (lei) return `Legal Entity: ${truncate(lei, 20)}`;
          return 'Legal Entity Credential';
        }
        if (credType === 'APE') return 'Auth Phone Entity';
        if (credType === 'DE') return 'Delegate Entity';
        if (credType === 'TNAlloc') {
          const tn = attrs.tn || attrs.phone || (attrs.numbers && attrs.numbers.rangeStart);
          if (tn) return `TN Allocation: ${tn}`;
          return 'TN Allocation';
        }
        if (credType === 'ROOT') return 'Trusted Root';
        if (credType === 'ISSUER') return 'Chain Terminus (Issuer)';
        return `Credential (${credType})`;
      }

      // Extract all displayable attributes from an ACDC
      function extractAllAttributes(attrs, credential) {
        if (!attrs || typeof attrs !== 'object') return [];
        const results = [];

        // LEI
        if (attrs.LEI) results.push({ label: 'LEI', value: attrs.LEI });
        if (attrs.lids && Array.isArray(attrs.lids)) {
          for (const lei of attrs.lids) {
            if (!results.find(r => r.value === lei)) {
              results.push({ label: 'LEI', value: lei });
            }
          }
        }

        // Phone numbers
        if (attrs.phone) {
          results.push({ label: 'Phone', value: Array.isArray(attrs.phone) ? attrs.phone.join(', ') : attrs.phone });
        }
        if (attrs.tn) {
          results.push({ label: 'TN', value: Array.isArray(attrs.tn) ? attrs.tn.join(', ') : attrs.tn });
        }
        if (attrs.numbers) {
          const range = attrs.numbers.rangeStart === attrs.numbers.rangeEnd
            ? attrs.numbers.rangeStart
            : `${attrs.numbers.rangeStart} - ${attrs.numbers.rangeEnd}`;
          results.push({ label: 'Number Range', value: range });
        }

        // Role
        if (attrs.role) results.push({ label: 'Role', value: attrs.role });

        // Organization from vCard
        if (attrs.vcard && Array.isArray(attrs.vcard)) {
          for (const line of attrs.vcard) {
            if (line.startsWith('ORG:')) {
              results.push({ label: 'Organization', value: line.substring(4) });
            }
            if (line.includes('LOGO;') && line.includes('VALUE=URI:')) {
              const url = line.match(/VALUE=URI:(.+)$/);
              if (url) results.push({ label: 'Logo', value: url[1], isUrl: true });
            }
          }
        }

        // Dates
        if (attrs.startDate) results.push({ label: 'Start Date', value: attrs.startDate });
        if (attrs.endDate) results.push({ label: 'End Date', value: attrs.endDate });
        if (attrs.dt) results.push({ label: 'Date', value: attrs.dt });

        // Geographic constraints
        if (attrs.c_pgeo) {
          results.push({ label: 'Permitted Geo', value: Array.isArray(attrs.c_pgeo) ? attrs.c_pgeo.join(', ') : attrs.c_pgeo });
        }

        // Level of assurance
        if (attrs.loa) results.push({ label: 'LoA', value: attrs.loa });

        // Legal name
        if (attrs.legalName) results.push({ label: 'Legal Name', value: attrs.legalName });
        if (attrs.organizationName) results.push({ label: 'Org Name', value: attrs.organizationName });

        // Country / Jurisdiction (for vetter constraints)
        if (attrs.country) results.push({ label: 'Country', value: attrs.country });
        if (attrs.jurisdiction) results.push({ label: 'Jurisdiction', value: attrs.jurisdiction });
        if (attrs.incorporation_country) results.push({ label: 'Incorporation', value: attrs.incorporation_country });

        // Vetter Certification fields (Sprint 40)
        if (attrs.ecc_targets && Array.isArray(attrs.ecc_targets)) {
          results.push({ label: 'ECC Targets', value: attrs.ecc_targets.slice(0, 5).join(', ') + (attrs.ecc_targets.length > 5 ? '...' : '') });
        }
        if (attrs.jurisdiction_targets && Array.isArray(attrs.jurisdiction_targets)) {
          results.push({ label: 'Jurisdiction Targets', value: attrs.jurisdiction_targets.slice(0, 5).join(', ') + (attrs.jurisdiction_targets.length > 5 ? '...' : '') });
        }
        if (attrs.certificationExpiry) results.push({ label: 'Certification Expiry', value: attrs.certificationExpiry });

        // Subject AID (issuee)
        if (attrs.i && attrs.i !== credential.i) {
          results.push({ label: 'Subject', value: truncate(attrs.i, 24) });
        }

        return results;
      }

      // Truncate string helper
      function truncate(str, len) {
        if (!str) return '';
        str = String(str);
        return str.length > len ? str.substring(0, len) + '...' : str;
      }

      // Handle credential link click - scroll to or highlight credential
      function handleCredentialLinkClick(targetSaid) {
        console.log('Credential link clicked:', targetSaid);

        // First check if we're in a modal (graph view)
        const modal = document.getElementById('graphModal');
        if (modal) {
          // Highlight the target in the graph
          const targetCard = modal.querySelector(`.credential-card[data-said="${targetSaid}"]`);
          if (targetCard) {
            targetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
            targetCard.style.boxShadow = '0 0 10px 3px #ffc107';
            setTimeout(() => targetCard.style.boxShadow = '', 2000);
            return;
          }
        }

        // Otherwise, scroll to credential in main dossier view
        const targetCard = document.querySelector(`.credential-card[data-said="${targetSaid}"]`);
        if (targetCard) {
          targetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
          targetCard.style.boxShadow = '0 0 10px 3px #ffc107';
          setTimeout(() => targetCard.style.boxShadow = '', 2000);
        } else {
          // Credential not in current view - search in all ACDCs
          const acdc = currentAcdcs.find(a => a.d === targetSaid);
          if (acdc) {
            alert(`Credential ${truncate(targetSaid, 16)} found but not currently displayed. Check the full dossier.`);
          } else {
            alert(`Credential ${truncate(targetSaid, 16)} not found in this dossier.`);
          }
        }
      }

      // Store revocation status map for credentials
      let currentRevocationStatus = {};

      // Display live revocation check results
      function displayLiveRevocationResults(results) {
        let html = `<div style="background:#f0f8ff;border:2px solid #0066cc;padding:1rem;border-radius:4px;margin-bottom:1rem;">`;
        html += `<h4 style="margin-top:0;color:#0066cc;">üîç Live Revocation Check Results</h4>`;
        html += `<p style="font-size:0.85em;color:#666;">Queried KERI witnesses/watchers for real-time credential status</p>`;

        let activeCount = 0;
        let revokedCount = 0;
        let unknownCount = 0;
        let errorCount = 0;

        for (const { acdc, result } of results) {
          const shortSaid = acdc.d ? acdc.d.substring(0, 16) + '...' : 'Unknown';

          let statusIcon, statusColor, statusText;
          if (result.status === "ACTIVE") {
            statusIcon = "‚úÖ";
            statusColor = "#28a745";
            statusText = "ACTIVE (Not Revoked)";
            activeCount++;
          } else if (result.status === "REVOKED") {
            statusIcon = "üö´";
            statusColor = "#dc3545";
            statusText = "REVOKED";
            revokedCount++;
          } else if (result.status === "UNKNOWN") {
            statusIcon = "‚ùì";
            statusColor = "#ffc107";
            statusText = "UNKNOWN (No TEL data from witnesses)";
            unknownCount++;
          } else {
            statusIcon = "‚ö†Ô∏è";
            statusColor = "#dc3545";
            statusText = `ERROR: ${result.error || 'Unknown error'}`;
            errorCount++;
          }

          html += `<div style="background:white;padding:0.5rem;margin:0.5rem 0;border-radius:4px;border-left:4px solid ${statusColor};">`;
          html += `<strong>${statusIcon} ${shortSaid}</strong><br>`;
          html += `<span style="color:${statusColor};font-weight:bold;">${statusText}</span>`;

          if (result.source) {
            html += `<br><span style="font-size:0.8em;color:#666;">Source: ${result.source}</span>`;
          }

          if (result.issuance) {
            html += `<br><span style="font-size:0.8em;color:#28a745;">Issued: ${result.issuance.datetime || 'Unknown date'}</span>`;
          }

          if (result.revocation) {
            html += `<br><span style="font-size:0.8em;color:#dc3545;">Revoked: ${result.revocation.datetime || 'Unknown date'}</span>`;
          }

          html += `</div>`;
        }

        // Summary
        html += `<p style="margin-bottom:0;font-size:0.9em;border-top:1px solid #ccc;padding-top:0.5rem;margin-top:0.5rem;">`;
        html += `<strong>Summary:</strong> `;
        if (activeCount > 0) html += `<span style="color:#28a745;">${activeCount} active</span> `;
        if (revokedCount > 0) html += `<span style="color:#dc3545;">${revokedCount} revoked</span> `;
        if (unknownCount > 0) html += `<span style="color:#ffc107;">${unknownCount} unknown</span> `;
        if (errorCount > 0) html += `<span style="color:#dc3545;">${errorCount} errors</span>`;
        html += `</p>`;

        html += `</div>`;

        // Prepend to dossier output
        const output = document.getElementById("dossierOutput");
        output.innerHTML = html + output.innerHTML;
      }

      // Build VVP-Identity header from parsed JWT data
      // Per VVP spec: ppt="vvp" (literal string), JWT goes in request body
      function buildVVPIdentityHeader(evdUrl, kidUrl, originalIat) {
        const header = {
          kid: kidUrl,         // OOBI URL for signer's key
          ppt: "vvp",          // Passport type identifier (always "vvp")
          evd: evdUrl,         // Evidence/dossier URL
          iat: originalIat,    // Use iat from the original PASSporT for consistency
        };

        // Base64url encode (no padding)
        const json = JSON.stringify(header);
        const base64 = btoa(json)
          .replace(/\+/g, '-')
          .replace(/\//g, '_')
          .replace(/=+$/, '');

        return base64;
      }

      // Run full verification against /verify endpoint
      async function runFullVerification() {
        const resultDiv = document.getElementById('verifyResult');
        resultDiv.innerHTML = '<p style="color:#666;"><em>Running verification...</em></p>';

        try {
          // Get values from current state
          const passportJwt = currentPassportJwt;
          const evdUrl = currentEvdUrl;
          const kidUrl = currentKidUrl;
          const originalIat = currentParsedPayload?.iat;

          if (!passportJwt || !evdUrl) {
            resultDiv.innerHTML = '<p style="color:#dc3545;">Missing JWT or evidence URL. Parse a JWT first.</p>';
            return;
          }

          if (!originalIat) {
            resultDiv.innerHTML = '<p style="color:#dc3545;">Could not extract iat from PASSporT payload.</p>';
            return;
          }

          // Build VVP-Identity header (ppt="vvp", JWT goes in body)
          const vvpIdentity = buildVVPIdentityHeader(evdUrl, kidUrl, originalIat);

          // Call /verify endpoint
          const response = await fetch('/verify', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'VVP-Identity': vvpIdentity,
            },
            body: JSON.stringify({
              passport_jwt: passportJwt,
              context: {
                call_id: 'ui-test-' + Date.now(),
                received_at: new Date().toISOString(),
              }
            }),
          });

          const data = await response.json();
          renderVerifyResult(data);

        } catch (err) {
          resultDiv.innerHTML = `<p style="color:#dc3545;">Verification failed: ${escapeHtml(err.message)}</p>`;
        }
      }

      // Render verification result with color-coded status
      function renderVerifyResult(result) {
        const status = result.overall_status || result.status || 'UNKNOWN';
        let statusClass, statusIcon, statusBg;

        if (status === 'VALID' || status === 'valid') {
          statusClass = '#28a745';
          statusIcon = '‚úì';
          statusBg = '#d4edda';
        } else if (status === 'INVALID' || status === 'invalid') {
          statusClass = '#dc3545';
          statusIcon = '‚úó';
          statusBg = '#f8d7da';
        } else {
          statusClass = '#ffc107';
          statusIcon = '‚ö†';
          statusBg = '#fff3cd';
        }

        let html = `
          <div style="background:${statusBg};border:2px solid ${statusClass};border-radius:4px;padding:1rem;margin-top:0.5rem;">
            <h4 style="margin:0 0 0.5rem 0;color:${statusClass};">${statusIcon} Verification Result: ${status.toUpperCase()}</h4>
        `;

        if (result.request_id) {
          html += `<p style="font-size:0.85em;color:#666;margin:0.25rem 0;">Request ID: ${escapeHtml(result.request_id)}</p>`;
        }

        // Show errors if any
        if (result.errors && result.errors.length > 0) {
          html += '<div style="margin-top:0.75rem;"><strong>Errors:</strong><ul style="margin:0.25rem 0 0 1rem;padding:0;">';
          for (const err of result.errors) {
            const code = err.code || err.error_code || 'ERROR';
            const msg = err.message || err.detail || JSON.stringify(err);
            html += `<li style="color:#dc3545;font-size:0.9em;"><strong>${escapeHtml(code)}</strong>: ${escapeHtml(msg)}</li>`;
          }
          html += '</ul></div>';
        }

        // Show warnings if any
        if (result.warnings && result.warnings.length > 0) {
          html += '<div style="margin-top:0.75rem;"><strong>Warnings:</strong><ul style="margin:0.25rem 0 0 1rem;padding:0;">';
          for (const warn of result.warnings) {
            html += `<li style="color:#856404;font-size:0.9em;">${escapeHtml(typeof warn === 'string' ? warn : JSON.stringify(warn))}</li>`;
          }
          html += '</ul></div>';
        }

        // Show claims summary if available
        if (result.claims && result.claims.length > 0) {
          html += '<div style="margin-top:0.75rem;"><strong>Verified Claims:</strong>';
          html += '<div style="background:white;padding:0.5rem;border-radius:4px;margin-top:0.25rem;font-size:0.85em;">';
          for (const claim of result.claims) {
            const claimStatus = claim.status || claim.valid ? '‚úì' : '‚úó';
            const claimName = claim.name || claim.type || 'Claim';
            html += `<div style="margin:2px 0;">${claimStatus} ${escapeHtml(claimName)}</div>`;
          }
          html += '</div></div>';
        }

        // Show brand info if available
        if (result.brand_name || result.brand_logo_url) {
          html += '<div style="margin-top:0.75rem;"><strong>Brand Information:</strong>';
          html += '<div style="background:white;padding:0.5rem;border-radius:4px;margin-top:0.25rem;display:flex;align-items:center;gap:0.5rem;">';
          if (result.brand_logo_url) {
            html += `<img src="${escapeHtml(result.brand_logo_url)}" style="max-height:32px;max-width:64px;" onerror="this.style.display='none'"/>`;
          }
          if (result.brand_name) {
            html += `<span style="font-weight:bold;">${escapeHtml(result.brand_name)}</span>`;
          }
          html += '</div></div>';
        }

        // Show raw response in collapsible
        html += `<details style="margin-top:0.75rem;">
          <summary style="cursor:pointer;font-size:0.85em;color:#666;">Raw Response</summary>
          <pre style="background:white;padding:0.5rem;overflow:auto;font-size:0.75em;max-height:200px;margin-top:0.25rem;">${escapeHtml(JSON.stringify(result, null, 2))}</pre>
        </details>`;

        html += '</div>';

        document.getElementById('verifyResult').innerHTML = html;
      }

      // Escape HTML helper
      function escapeHtml(text) {
        if (text === null || text === undefined) return '';
        const div = document.createElement('div');
        div.textContent = String(text);
        return div.innerHTML;
      }

      // Run Verify button click handler
      document.getElementById("runVerifyBtn").addEventListener("click", runFullVerification);
    </script>
  </body>
</html>
