{# Credential chain graph partial - SVG-based visualization #}
{#
   Renders a pure SVG graph with boxes and arrows.
   Mouseover on boxes shows the full credential card.
#}

{% if error %}
<article aria-invalid="true">
    <header>Graph Error</header>
    <p>{{ error }}</p>
</article>
{% else %}

<h3>Credential Chain Graph</h3>

{# Trust path indicator #}
{% if graph.trustPathValid %}
<article style="background:var(--vvp-success);color:white;padding:0.5rem 1rem;">
    Valid trust path to root
</article>
{% else %}
<article aria-invalid="true" style="padding:0.5rem 1rem;">
    No valid trust path to root (issuer not in trusted roots list)
</article>
{% endif %}

{% if graph.layers and graph.layers | length > 0 %}

{# SVG Graph Container #}
<div class="svg-graph-wrapper" style="position:relative;">
    <svg id="credential-graph-svg" class="credential-graph-svg"></svg>

    {# Floating credential card panel (hidden by default) #}
    <div id="credential-popup" class="credential-popup" style="display:none;"></div>
</div>

{# Hidden credential cards for popup content #}
<div id="credential-cards-data" style="display:none;">
    {% for node in graph.nodes %}
    <div data-node-id="{{ node.id }}">
        {% if credential_vms and node.id in credential_vms %}
            {% set vm = credential_vms[node.id] %}
            {% include "partials/credential_card.html" %}
        {% else %}
            {% set acdc = {
                'd': node.id,
                'i': node.issuer,
                's': node.schemaSaid,
                'type': node.type,
                'displayName': node.displayName,
                'status': node.status or 'UNKNOWN',
                'a': node.attributes or {},
                'e': node.edges or {}
            } %}
            {% include "partials/credential_card.html" %}
        {% endif %}
    </div>
    {% endfor %}
</div>

{# Graph data for JavaScript #}
<script>
(function() {
    const graphData = {
        nodes: {{ graph.nodes | tojson }},
        edges: {{ graph.edges | tojson }},
        layers: {{ graph.layers | tojson }},
        trustPathValid: {{ graph.trustPathValid | tojson }}
    };

    // Layout constants
    const BOX_WIDTH = 160;
    const BOX_HEIGHT = 60;
    const LAYER_GAP = 100;
    const NODE_GAP = 40;
    const PADDING = 40;

    // Color scheme by credential type
    const typeColors = {
        'ROOT': '#6f42c1',
        'ISSUER': '#17a2b8',
        'LE': '#20c997',
        'APE': '#fd7e14',
        'DE': '#e83e8c',
        'TNAlloc': '#007bff',
        'UNKNOWN': '#6c757d'
    };

    // Edge colors by type
    const edgeColors = {
        'vetting': '#28a745',
        'delegation': '#007bff',
        'issued_by': '#6f42c1',
        'issuer': '#17a2b8',
        'jl': '#fd7e14',
        'default': '#6c757d'
    };

    // Build node position map
    const nodePositions = {};
    let maxWidth = 0;

    graphData.layers.forEach((layerIds, layerIndex) => {
        const y = PADDING + layerIndex * (BOX_HEIGHT + LAYER_GAP);
        const layerWidth = layerIds.length * (BOX_WIDTH + NODE_GAP) - NODE_GAP;
        maxWidth = Math.max(maxWidth, layerWidth);

        layerIds.forEach((nodeId, nodeIndex) => {
            const x = PADDING + nodeIndex * (BOX_WIDTH + NODE_GAP);
            nodePositions[nodeId] = { x, y, layerIndex };
        });
    });

    // Center each layer
    graphData.layers.forEach((layerIds, layerIndex) => {
        const layerWidth = layerIds.length * (BOX_WIDTH + NODE_GAP) - NODE_GAP;
        const offset = (maxWidth - layerWidth) / 2;
        layerIds.forEach(nodeId => {
            nodePositions[nodeId].x += offset;
        });
    });

    const svgWidth = maxWidth + PADDING * 2;
    const svgHeight = graphData.layers.length * (BOX_HEIGHT + LAYER_GAP) - LAYER_GAP + PADDING * 2;

    // Create SVG
    const svg = document.getElementById('credential-graph-svg');
    svg.setAttribute('width', svgWidth);
    svg.setAttribute('height', svgHeight);
    svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

    // Arrow marker definition
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.innerHTML = `
        <marker id="arrow" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto" markerUnits="strokeWidth">
            <polygon points="0 0, 10 3.5, 0 7" fill="#6c757d"/>
        </marker>
    `;
    svg.appendChild(defs);

    // Draw edges first (so they're behind nodes)
    graphData.edges.forEach(edge => {
        const fromPos = nodePositions[edge.from];
        const toPos = nodePositions[edge.to];

        if (fromPos && toPos) {
            const x1 = fromPos.x + BOX_WIDTH / 2;
            const y1 = fromPos.y + BOX_HEIGHT;
            const x2 = toPos.x + BOX_WIDTH / 2;
            const y2 = toPos.y;

            // Bezier curve
            const midY = (y1 + y2) / 2;
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M ${x1} ${y1} C ${x1} ${midY}, ${x2} ${midY}, ${x2} ${y2}`);
            path.setAttribute('stroke', edgeColors[edge.type] || edgeColors.default);
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            path.setAttribute('marker-end', 'url(#arrow)');

            // Add edge type label
            const labelX = (x1 + x2) / 2;
            const labelY = midY;
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', labelX);
            label.setAttribute('y', labelY);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-size', '10');
            label.setAttribute('fill', edgeColors[edge.type] || edgeColors.default);
            label.textContent = edge.type;

            svg.appendChild(path);
            svg.appendChild(label);
        }
    });

    // Draw nodes
    graphData.nodes.forEach(node => {
        const pos = nodePositions[node.id];
        if (!pos) return;

        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        group.setAttribute('class', 'graph-node');
        group.setAttribute('data-node-id', node.id);
        group.style.cursor = 'pointer';

        // Box
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', pos.x);
        rect.setAttribute('y', pos.y);
        rect.setAttribute('width', BOX_WIDTH);
        rect.setAttribute('height', BOX_HEIGHT);
        rect.setAttribute('rx', '8');
        rect.setAttribute('fill', '#fff');
        rect.setAttribute('stroke', typeColors[node.type] || typeColors.UNKNOWN);
        rect.setAttribute('stroke-width', '3');

        // Type badge background
        const badgeWidth = 60;
        const badge = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        badge.setAttribute('x', pos.x + (BOX_WIDTH - badgeWidth) / 2);
        badge.setAttribute('y', pos.y + 5);
        badge.setAttribute('width', badgeWidth);
        badge.setAttribute('height', '18');
        badge.setAttribute('rx', '4');
        badge.setAttribute('fill', typeColors[node.type] || typeColors.UNKNOWN);

        // Type label
        const typeLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        typeLabel.setAttribute('x', pos.x + BOX_WIDTH / 2);
        typeLabel.setAttribute('y', pos.y + 18);
        typeLabel.setAttribute('text-anchor', 'middle');
        typeLabel.setAttribute('font-size', '11');
        typeLabel.setAttribute('font-weight', 'bold');
        typeLabel.setAttribute('fill', '#fff');
        typeLabel.textContent = node.type || 'UNKNOWN';

        // Display name or truncated SAID
        const displayText = node.displayName || node.id.substring(0, 12) + '...';
        const nameLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        nameLabel.setAttribute('x', pos.x + BOX_WIDTH / 2);
        nameLabel.setAttribute('y', pos.y + 40);
        nameLabel.setAttribute('text-anchor', 'middle');
        nameLabel.setAttribute('font-size', '11');
        nameLabel.setAttribute('fill', '#333');
        nameLabel.textContent = displayText.length > 18 ? displayText.substring(0, 18) + '...' : displayText;

        // Status indicator
        const statusColor = node.status === 'ACTIVE' ? '#28a745' : (node.status === 'REVOKED' ? '#dc3545' : '#ffc107');
        const statusDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        statusDot.setAttribute('cx', pos.x + BOX_WIDTH - 12);
        statusDot.setAttribute('cy', pos.y + 12);
        statusDot.setAttribute('r', '5');
        statusDot.setAttribute('fill', statusColor);

        // Root indicator
        if (node.isRoot) {
            const rootBadge = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            rootBadge.setAttribute('x', pos.x + 10);
            rootBadge.setAttribute('y', pos.y + 15);
            rootBadge.setAttribute('font-size', '10');
            rootBadge.setAttribute('fill', '#6f42c1');
            rootBadge.textContent = 'â˜…';
            group.appendChild(rootBadge);
        }

        group.appendChild(rect);
        group.appendChild(badge);
        group.appendChild(typeLabel);
        group.appendChild(nameLabel);
        group.appendChild(statusDot);

        // Mouseover events
        group.addEventListener('mouseenter', (e) => showCredentialPopup(node.id, e));
        group.addEventListener('mouseleave', hideCredentialPopup);

        svg.appendChild(group);
    });

    // Popup handling
    const popup = document.getElementById('credential-popup');
    const cardsData = document.getElementById('credential-cards-data');

    function showCredentialPopup(nodeId, event) {
        const cardData = cardsData.querySelector(`[data-node-id="${nodeId}"]`);
        if (cardData) {
            popup.innerHTML = cardData.innerHTML;
            popup.style.display = 'block';

            // Position popup near the mouse but within viewport
            const rect = popup.getBoundingClientRect();
            const svgRect = svg.getBoundingClientRect();

            let left = event.clientX - svgRect.left + 20;
            let top = event.clientY - svgRect.top - 20;

            // Keep within container
            if (left + 400 > svgRect.width) {
                left = event.clientX - svgRect.left - 420;
            }
            if (top < 0) top = 10;

            popup.style.left = left + 'px';
            popup.style.top = top + 'px';
        }
    }

    function hideCredentialPopup() {
        popup.style.display = 'none';
    }
})();
</script>

<style>
    .svg-graph-wrapper {
        overflow-x: auto;
        background: #fafafa;
        border: 1px solid #dee2e6;
        border-radius: 0.5rem;
        padding: 1rem;
    }

    .credential-graph-svg {
        display: block;
        margin: 0 auto;
    }

    .graph-node:hover rect {
        filter: brightness(0.95);
    }

    .credential-popup {
        position: absolute;
        z-index: 1000;
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 0.5rem;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        max-width: 400px;
        max-height: 500px;
        overflow-y: auto;
        padding: 0.5rem;
    }

    .credential-popup .credential-card {
        margin: 0;
        border: none;
    }
</style>

{% elif graph.nodes and graph.nodes | length > 0 %}
<article>
    <p>No layers computed, but {{ graph.nodes | length }} node(s) exist.</p>
</article>
{% else %}
<article aria-invalid="true">
    <p>No credentials found in graph.</p>
</article>
{% endif %}

{% endif %}
