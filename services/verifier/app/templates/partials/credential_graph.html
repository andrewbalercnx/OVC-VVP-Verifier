{# Credential chain graph partial - SVG-based visualization #}
{#
   Renders a pure SVG graph with boxes and arrows.
   Mouseover on boxes shows the full credential card.
#}

{% if error %}
<article aria-invalid="true">
    <header>Graph Error</header>
    <p>{{ error }}</p>
</article>
{% else %}

<h3>Credential Chain Graph</h3>

{# Legend for DAG visualization #}
<details style="margin-bottom: 0.5rem; font-size: 0.85rem;">
    <summary style="cursor: pointer; color: var(--pico-muted-color);">Graph Legend</summary>
    <div style="display: flex; flex-wrap: wrap; gap: 1rem; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; margin-top: 0.5rem;">
        <span><span style="color: #28a745;">●</span> Valid trust flow (top→bottom)</span>
        <span><span style="color: #dc3545;">●</span> Back-reference (warning)</span>
        <span><span style="color: #6f42c1;">■</span> Root of Trust</span>
        <span><span style="color: #17a2b8;">■</span> QVI/Issuer</span>
        <span><span style="color: #20c997;">■</span> Legal Entity</span>
        <span><span style="color: #fd7e14;">■</span> APE</span>
        <span><span style="color: #007bff;">■</span> TNAlloc</span>
    </div>
</details>

{# Trust path indicator #}
{% if graph.trustPathValid %}
<article style="background:var(--vvp-success);color:white;padding:0.5rem 1rem;">
    Valid trust path to root
</article>
{% else %}
<article aria-invalid="true" style="padding:0.5rem 1rem;">
    No valid trust path to root (issuer not in trusted roots list)
</article>
{% endif %}

{% if graph.layers and graph.layers | length > 0 %}

{# SVG Graph Container #}
<div class="svg-graph-wrapper" style="position:relative;">
    <svg id="credential-graph-svg" class="credential-graph-svg"></svg>

    {# Floating credential card panel (hidden by default) #}
    <div id="credential-popup" class="credential-popup" style="display:none;"></div>
</div>

{# Hidden credential cards for popup content #}
<div id="credential-cards-data" style="display:none;">
    {% for node in graph.nodes %}
    <div data-node-id="{{ node.id }}">
        {% if credential_vms and node.id in credential_vms %}
            {% set vm = credential_vms[node.id] %}
            {% include "partials/credential_card.html" %}
        {% else %}
            {% set acdc = {
                'd': node.id,
                'i': node.issuer,
                's': node.schemaSaid,
                'type': node.type,
                'displayName': node.displayName,
                'status': node.status or 'UNKNOWN',
                'a': node.attributes or {},
                'e': node.edges or {}
            } %}
            {% include "partials/credential_card.html" %}
        {% endif %}
    </div>
    {% endfor %}
</div>

{# Graph data for JavaScript #}
<script>
(function() {
    const graphData = {
        nodes: {{ graph.nodes | tojson }},
        edges: {{ graph.edges | tojson }},
        layers: {{ graph.layers | tojson }},
        trustPathValid: {{ graph.trustPathValid | tojson }}
    };

    // Layout constants
    const BOX_WIDTH = 160;
    const BOX_HEIGHT = 60;
    const LAYER_GAP = 100;
    const NODE_GAP = 40;
    const PADDING = 40;

    // Color scheme by credential type
    const typeColors = {
        'ROOT': '#6f42c1',
        'ISSUER': '#17a2b8',
        'LE': '#20c997',
        'APE': '#fd7e14',
        'DE': '#e83e8c',
        'TNAlloc': '#007bff',
        'UNKNOWN': '#6c757d'
    };

    // Edge colors by type
    const edgeColors = {
        'vetting': '#28a745',
        'delegation': '#007bff',
        'issued_by': '#6f42c1',
        'issuer': '#17a2b8',
        'jl': '#fd7e14',
        'default': '#6c757d'
    };

    // Build node position map
    const nodePositions = {};
    let maxWidth = 0;

    graphData.layers.forEach((layerIds, layerIndex) => {
        const y = PADDING + layerIndex * (BOX_HEIGHT + LAYER_GAP);
        const layerWidth = layerIds.length * (BOX_WIDTH + NODE_GAP) - NODE_GAP;
        maxWidth = Math.max(maxWidth, layerWidth);

        layerIds.forEach((nodeId, nodeIndex) => {
            const x = PADDING + nodeIndex * (BOX_WIDTH + NODE_GAP);
            nodePositions[nodeId] = { x, y, layerIndex };
        });
    });

    // Center each layer
    graphData.layers.forEach((layerIds, layerIndex) => {
        const layerWidth = layerIds.length * (BOX_WIDTH + NODE_GAP) - NODE_GAP;
        const offset = (maxWidth - layerWidth) / 2;
        layerIds.forEach(nodeId => {
            nodePositions[nodeId].x += offset;
        });
    });

    const svgWidth = maxWidth + PADDING * 2;
    const svgHeight = graphData.layers.length * (BOX_HEIGHT + LAYER_GAP) - LAYER_GAP + PADDING * 2;

    // Create SVG
    const svg = document.getElementById('credential-graph-svg');
    svg.setAttribute('width', svgWidth);
    svg.setAttribute('height', svgHeight);
    svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

    // Arrow marker definitions (green for normal flow, red for back-references)
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.innerHTML = `
        <marker id="arrow-down" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto" markerUnits="strokeWidth">
            <polygon points="0 0, 10 3.5, 0 7" fill="#28a745"/>
        </marker>
        <marker id="arrow-up" markerWidth="10" markerHeight="7" refX="1" refY="3.5" orient="auto" markerUnits="strokeWidth">
            <polygon points="10 0, 0 3.5, 10 7" fill="#dc3545"/>
        </marker>
    `;
    svg.appendChild(defs);

    // Layer labels for trust hierarchy
    const layerLabels = ['Root of Trust', 'Authority', 'Delegation', 'Leaf'];

    // Draw layer separator lines (dashed, subtle)
    graphData.layers.forEach((layerIds, layerIndex) => {
        if (layerIndex === 0) return;

        const y = PADDING + layerIndex * (BOX_HEIGHT + LAYER_GAP) - LAYER_GAP / 2;
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', 0);
        line.setAttribute('y1', y);
        line.setAttribute('x2', svgWidth);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', '#dee2e6');
        line.setAttribute('stroke-dasharray', '4,4');
        svg.appendChild(line);
    });

    // Draw layer labels on left side
    graphData.layers.forEach((layerIds, layerIndex) => {
        const y = PADDING + layerIndex * (BOX_HEIGHT + LAYER_GAP) + BOX_HEIGHT / 2;
        const labelText = layerLabels[Math.min(layerIndex, layerLabels.length - 1)];

        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', 8);
        label.setAttribute('y', y);
        label.setAttribute('font-size', '10');
        label.setAttribute('fill', '#6c757d');
        label.setAttribute('text-anchor', 'start');
        label.setAttribute('dominant-baseline', 'middle');
        label.textContent = `L${layerIndex}`;
        svg.appendChild(label);
    });

    // Draw edges with DAG-correct direction (parent → child, arrows point DOWN)
    // Data model: edge.from = child, edge.to = parent
    // Display model: arrows point from parent to child (top to bottom)
    graphData.edges.forEach(edge => {
        const childPos = nodePositions[edge.from];   // Child is "from" in data model
        const parentPos = nodePositions[edge.to];    // Parent is "to" in data model

        if (childPos && parentPos) {
            // Determine if this is a back-reference (parent at same or lower layer than child)
            // In correct DAG: parentLayer < childLayer (parent higher/earlier, child lower/later)
            const childLayer = childPos.layerIndex;
            const parentLayer = parentPos.layerIndex;
            const isBackReference = parentLayer >= childLayer;

            let startX, startY, endX, endY;
            if (!isBackReference) {
                // Normal DAG flow: draw from parent (top) to child (bottom)
                startX = parentPos.x + BOX_WIDTH / 2;
                startY = parentPos.y + BOX_HEIGHT;   // Bottom of parent
                endX = childPos.x + BOX_WIDTH / 2;
                endY = childPos.y;                    // Top of child
            } else {
                // Back-reference: draw from child (bottom) upward to parent
                startX = childPos.x + BOX_WIDTH / 2;
                startY = childPos.y;                  // Top of child
                endX = parentPos.x + BOX_WIDTH / 2;
                endY = parentPos.y + BOX_HEIGHT;      // Bottom of parent
            }

            // Bezier curve
            const midY = (startY + endY) / 2;
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M ${startX} ${startY} C ${startX} ${midY}, ${endX} ${midY}, ${endX} ${endY}`);

            // Use red for back-references, normal color for regular edges
            const strokeColor = isBackReference ? '#dc3545' : (edgeColors[edge.type] || edgeColors.default);
            path.setAttribute('stroke', strokeColor);
            path.setAttribute('stroke-width', isBackReference ? '3' : '2');
            path.setAttribute('fill', 'none');
            path.setAttribute('marker-end', isBackReference ? 'url(#arrow-up)' : 'url(#arrow-down)');

            if (isBackReference) {
                path.setAttribute('stroke-dasharray', '5,3');
            }

            // Add edge type label
            const labelX = (startX + endX) / 2;
            const labelY = midY;
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', labelX);
            label.setAttribute('y', labelY);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-size', '10');
            label.setAttribute('fill', strokeColor);
            label.textContent = edge.type + (isBackReference ? ' ⚠' : '');

            svg.appendChild(path);
            svg.appendChild(label);
        }
    });

    // Draw nodes
    graphData.nodes.forEach(node => {
        const pos = nodePositions[node.id];
        if (!pos) return;

        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        group.setAttribute('class', 'graph-node');
        group.setAttribute('data-node-id', node.id);
        group.style.cursor = 'pointer';

        // Box
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', pos.x);
        rect.setAttribute('y', pos.y);
        rect.setAttribute('width', BOX_WIDTH);
        rect.setAttribute('height', BOX_HEIGHT);
        rect.setAttribute('rx', '8');
        rect.setAttribute('fill', '#fff');
        rect.setAttribute('stroke', typeColors[node.type] || typeColors.UNKNOWN);
        rect.setAttribute('stroke-width', '3');

        // Type badge background
        const badgeWidth = 60;
        const badge = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        badge.setAttribute('x', pos.x + (BOX_WIDTH - badgeWidth) / 2);
        badge.setAttribute('y', pos.y + 5);
        badge.setAttribute('width', badgeWidth);
        badge.setAttribute('height', '18');
        badge.setAttribute('rx', '4');
        badge.setAttribute('fill', typeColors[node.type] || typeColors.UNKNOWN);

        // Type label
        const typeLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        typeLabel.setAttribute('x', pos.x + BOX_WIDTH / 2);
        typeLabel.setAttribute('y', pos.y + 18);
        typeLabel.setAttribute('text-anchor', 'middle');
        typeLabel.setAttribute('font-size', '11');
        typeLabel.setAttribute('font-weight', 'bold');
        typeLabel.setAttribute('fill', '#fff');
        typeLabel.textContent = node.type || 'UNKNOWN';

        // Display name or truncated SAID
        const displayText = node.displayName || node.id.substring(0, 12) + '...';
        const nameLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        nameLabel.setAttribute('x', pos.x + BOX_WIDTH / 2);
        nameLabel.setAttribute('y', pos.y + 40);
        nameLabel.setAttribute('text-anchor', 'middle');
        nameLabel.setAttribute('font-size', '11');
        nameLabel.setAttribute('fill', '#333');
        nameLabel.textContent = displayText.length > 18 ? displayText.substring(0, 18) + '...' : displayText;

        // Status indicator
        const statusColor = node.status === 'ACTIVE' ? '#28a745' : (node.status === 'REVOKED' ? '#dc3545' : '#ffc107');
        const statusDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        statusDot.setAttribute('cx', pos.x + BOX_WIDTH - 12);
        statusDot.setAttribute('cy', pos.y + 12);
        statusDot.setAttribute('r', '5');
        statusDot.setAttribute('fill', statusColor);

        // Root indicator
        if (node.isRoot) {
            const rootBadge = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            rootBadge.setAttribute('x', pos.x + 10);
            rootBadge.setAttribute('y', pos.y + 15);
            rootBadge.setAttribute('font-size', '10');
            rootBadge.setAttribute('fill', '#6f42c1');
            rootBadge.textContent = '★';
            group.appendChild(rootBadge);
        }

        group.appendChild(rect);
        group.appendChild(badge);
        group.appendChild(typeLabel);
        group.appendChild(nameLabel);
        group.appendChild(statusDot);

        // Mouseover events
        group.addEventListener('mouseenter', (e) => showCredentialPopup(node.id, e));
        group.addEventListener('mouseleave', hideCredentialPopup);

        svg.appendChild(group);
    });

    // Popup handling
    const popup = document.getElementById('credential-popup');
    const cardsData = document.getElementById('credential-cards-data');

    function showCredentialPopup(nodeId, event) {
        const cardData = cardsData.querySelector(`[data-node-id="${nodeId}"]`);
        if (cardData) {
            popup.innerHTML = cardData.innerHTML;
            popup.style.display = 'block';

            // Position popup near the mouse but within viewport
            const rect = popup.getBoundingClientRect();
            const svgRect = svg.getBoundingClientRect();

            let left = event.clientX - svgRect.left + 20;
            let top = event.clientY - svgRect.top - 20;

            // Keep within container
            if (left + 400 > svgRect.width) {
                left = event.clientX - svgRect.left - 420;
            }
            if (top < 0) top = 10;

            popup.style.left = left + 'px';
            popup.style.top = top + 'px';
        }
    }

    function hideCredentialPopup() {
        popup.style.display = 'none';
    }
})();
</script>

<style>
    .svg-graph-wrapper {
        overflow-x: auto;
        background: #fafafa;
        border: 1px solid #dee2e6;
        border-radius: 0.5rem;
        padding: 1rem;
    }

    .credential-graph-svg {
        display: block;
        margin: 0 auto;
    }

    .graph-node:hover rect {
        filter: brightness(0.95);
    }

    .credential-popup {
        position: absolute;
        z-index: 1000;
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 0.5rem;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        max-width: 400px;
        max-height: 500px;
        overflow-y: auto;
        padding: 0.5rem;
    }

    .credential-popup .credential-card {
        margin: 0;
        border: none;
    }
</style>

{% elif graph.nodes and graph.nodes | length > 0 %}
<article>
    <p>No layers computed, but {{ graph.nodes | length }} node(s) exist.</p>
</article>
{% else %}
<article aria-invalid="true">
    <p>No credentials found in graph.</p>
</article>
{% endif %}

{% endif %}
